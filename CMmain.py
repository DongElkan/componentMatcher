# -*- coding: utf-8 -*-
"""
Main GUI of componentMatcher. componentMatcher is a simple GUI for finding common
components from HPLC-DAD fingerprints of TCM compound and single medicine according
to experimental condition defined by Hong Kong Chinese Materia Medica Standards
(HKCMMS) of corresponding single medicine. In current package, spectral correlative
chromatography (SCC) method is used to match HPLC-DAD fingerprint peaks derived
from TCM compound and single medicine. Prior to this, baseline correction is
performed.

This package is lisenced under the terms of Apache License, version 2.0.
Copyright to Nai-ping Dong, PolyU in Hong Kong, 2014.

E-mail: np.dong572@gmail.com
"""



import tkinter.messagebox as tkm
import tkinter.filedialog as tkd
import tkinter as tk
import numpy as np
import tkinter.ttk
import os
import gc
import mscc
import figparams

from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg as FigureCanvas
from matplotlib.backends.backend_tkagg import NavigationToolbar2TkAgg
from matplotlib.backends.backend_tkagg import ToolTip
from matplotlib.backends.backend_tkagg import cursord

from aboutcm import aboutCM


# Set up dialog texts
DIAGTEXT    ={'reftxt'      :'Please select corresponding\nexperimental method:',
              'markerrtanno':'Retention times of markers, must contain two time points each '+\
                             'marker: start and end time of elution, separated by space; if\n'+\
                             'several markers existed, semicolons ";" must be used as '+\
                             'delimiters between markers. e.g., 24.9 25.3;37.6 38.05.',
              'nameanno'    :'Name of method, single medicine name or its abbreviation '+\
                             'is recommended since this is also used as the name in method '+\
                             'list\nfor selection when you analyze the compound raw data.',
              'waveanno'    :'Wavelength displayed defaultedly, usually the one selected '+\
                             'as the fingerprint of the medicine. Must be an integer.',
              'namewarnmsg' :'The method name has been assigned,\nare you sure you want '+\
                             'to overwrite it?',
              'libinfo'     :['# Method name\nNAME=',
                              '# Marker retention times\nMARKERRT=',
                              '# Selected wavelength for fingerprint showing\nWVMAIN=',
                              '# Minimum wavelength used for matching makers. Generally, this is '+\
                                'used to eliminate serious baseline distortion generated by '+\
                                'chromatographic conditions.\nWVTHR=',
                              '# Retention time of fingerprint method\nTIME=',
                              '# Wavelength of fingerprint method\nWAVELENGTH='],
                             }
# Set up global parameters
CURRENTLIBPATH=os.path.join(os.getcwd(),'lib')        # Lib path
RTERR = 0.8                                # Retention error to find maker peaks
DEFAULTCURSOR =cursord[1]


# -----------------------------------------------------------------------------
## read method list in lib directory
def get_methodlist():
    """ Read method list in lib directory """
    expmethods=[]
    if not os.path.isdir(CURRENTLIBPATH): return expmethods
    
    files     =os.listdir(CURRENTLIBPATH)
    for name in files:
        if name.endswith('.info'):
            expmethods.append(name.split('.')[0])
    return expmethods


# -----------------------------------------------------------------------------
## set hand cursor when mouse moves over the activated text
class OnHover(object):
    """ Set hand cursor when mouse moves over the text that has callbacks
        in MainGUI.
        Input:
            artist  text artist where hand cursor set
    """
    def __init__(self, artists, cursor='hand2'):
        self.artist = artists
        self.cursor = cursor
        self.fig    = [artist.axes.figure for artist in artists]

    def __call__(self, event):
        for artist in self.artist:
            inside, _ = artist.contains(event)
            if inside:
                break
        
        if inside:
            cursord[1]= self.cursor
        else:
            cursord[1]= DEFAULTCURSOR
            
        for fig in self.fig:
            fig.canvas.toolbar.set_cursor(1)


# -----------------------------------------------------------------------------
## customize navigation toolbar for MainGUI
class NavigationToolbar(NavigationToolbar2TkAgg):
    """ Navigation toolbar of MainGUI. """
    # tool items of tool bar
    toolitems=(
               ('Home', 'Reset to original view', 'home', 'home'),
               ('Pan', 'Pan axes with left mouse, zoom with right', 'move', 'pan'),
               ('Zoom', 'Zoom figure to rectangle', 'zoom_to_rect', 'zoom')
               )
    
    def __init__(self,parent):
        self.parent = parent
        self.toolids= parent.toolids
        self.figure = parent.figure
        self.mvcid  = parent.mvcid
        NavigationToolbar2TkAgg.__init__(self, parent.canvas, parent.root)
        
    def home(self):
        """ Redefine home for navigation toolbar of matplotlib, as the default function will
            produce unexpected figure. As posted in http://stackoverflow.com/q/27906253/3003072
        """
        refxlow, refxup     = self.parent.refdax.get_xbound()
        refylow, refyup     = self.parent.refdax.get_ybound()
        rawxlow, rawxup     = self.parent.rawdax.get_xbound()
        rawylow, rawyup     = self.parent.rawdax.get_ybound()
        refxylims,rawxylims = self.parent.refxylims,self.parent.rawxylims
        if refxlow is not refxylims[0][0] or refxup is not refxylims[0][1]:
            self.parent.refdax.set_xlim(refxylims[0])
            self.parent.refdax.set_ylim(refxylims[1])
            self.parent.refdax.figure.canvas.draw_idle()
        
        if rawxlow is not rawxylims[0][0] or rawxup is not rawxylims[0][1]:
            self.parent.rawdax.set_xlim(rawxylims[0])
            self.parent.rawdax.set_ylim(rawxylims[1])
            self.parent.rawdax.figure.canvas.draw_idle()

    def zoom(self):
        """ Redefine zoom function for navigation toolbar of matplotlib """
        # set label to identify whether toolbar is activated
        if self.toolids[1]: # activated but now deactivated
            wvtxt           =self.parent.wvtxt
            self.mvcid      =self.figure.canvas.mpl_connect('motion_notify_event', OnHover(wvtxt))
            self.toolids[1] =False
        else:
            self.figure.canvas.mpl_disconnect(self.mvcid)
            self.toolids[1] = True
        NavigationToolbar2TkAgg.zoom(self)

    def pan(self):
        """ Redefine pan function for navigation toolbar of matplotlib """
        if self.toolids[0]: # activated but now deactivated
            wvtxt           =self.parent.wvtxt
            self.mvcid = self.figure.canvas.mpl_connect('motion_notify_event', OnHover(wvtxt))
            self.toolids[0] = False
        else:
            self.figure.canvas.mpl_disconnect(self.mvcid)
            self.toolids[0] = True
        NavigationToolbar2TkAgg.pan(self)


# -----------------------------------------------------------------------------
## customize navigation toolbar for lib constructor interface
class NavigationToolbarInLibFig(NavigationToolbar2TkAgg):
    """ Reset the location of navigation toolbar in lib constructor interface as the default
        location is at the buttom of the interface. This can be achieved by modifying the attribute
        _init_toolbar of the original NavigationToolbar2 calss """
    toolitems=(
               ('Home', 'Reset original view', 'home', 'home'),
               ('Pan', 'Pan axes with left mouse, zoom with right', 'move', 'pan'),
               ('Zoom', 'Zoom to rectangle', 'zoom_to_rect', 'zoom'),
               ('Save', 'Save the figure', 'filesave', 'save_figure')
               )
    def _init_toolbar(self):
        xmin, xmax = self.canvas.figure.bbox.intervalx
        height, width = 50/20, (xmax-xmin)/20
        tk.Frame.__init__(self, master=self.window,
                          width=int(width), height=int(height),
                          borderwidth=1)

        self.update()  # Make axes menu

        for text, tooltip_text, image_file, callback in self.toolitems:
            button = self._Button(text=text, file=image_file,command=getattr(self, callback))
            ToolTip.createToolTip(button, tooltip_text)

        self.message = tk.StringVar(master=self)
        self._message_label = tk.Label(master=self, textvariable=self.message)
        self._message_label.pack(side=tk.RIGHT)
        self.pack(side=tk.TOP, fill=tk.X)


# -----------------------------------------------------------------------------
## MAIN GUI
class MainGUI(object):
    """ Main GUI of componentMatcher """
    def __init__(self,root):
        self.root = root
        self.creatMainWin()
    
    def creatMainWin(self):
        self.root['bg'] = 'white'
        self.makeMenu()
        self.mainFigureWin()
    
    def makeMenu(self):
        topmenus = tk.Menu(self.root)
        self.root.config(menu=topmenus)
        
        menufile = tk.Menu(topmenus, tearoff=False)
        menufile.add_command(label='Load Data', command=self.rawDataLoad, underline=0)
        menufile.add_command(label='Quit',      command=self._quit,       underline=0)
        topmenus.add_cascade(label='File',      menu=menufile,            underline=0)
        
        menutool = tk.Menu(topmenus, tearoff=False)
        menutool.add_command(label    ='Load Reference',
                             command  =(lambda: self.selectRefMethod(False)),
                             state='disabled',
                             underline=0)
        menutool.add_command(label    ='Generate Report',
                             command  =self.forResultsGenerator,
                             state='disabled',
                             underline=0)
        menutool.add_command(label    ='Add Reference',
                             command  =self.forLibConstructor,
                             underline=0)
        topmenus.add_cascade(label='Tool',    menu=menutool,       underline=0)
        self.menutools = menutool
        
        menuhelp = tk.Menu(topmenus, tearoff=False)
        menuhelp.add_command(label='CM Docs', command=self.openDoc,underline=0)
        menuhelp.add_separator()
        menuhelp.add_command(label='About CM',command=aboutCM,     underline=0)
        topmenus.add_cascade(label='Help',    menu=menuhelp,       underline=0)
    
    def mainFigureWin(self):
        self.figure = Figure(figsize=(10,6), facecolor='white', edgecolor='white')
        self.canvas = FigureCanvas(self.figure, master=self.root)
        self.canvas.get_tk_widget().pack(side='top', fill='both', expand=1)
    
    def rawDataLoad(self):
        """ Load raw data specified by user. If the raw data has been loaded, no
            subsequent analysis is performed. """
        if 'rawdatafile' not in list(self.__dict__.keys()):
            self.methods= get_methodlist()
            if len(self.methods)==0:
                tkm.showerror('Invalid operation',
                              'No method constructed in library!\nYou must '+\
                              'construct the method library first.')
                return
            
            # stores toplevel instance for selection, 'refmethod' is for reference methods,
            # 'ref' is for reference, and 'raw' is for raw data
            self.selectwins ={'refmethod':{'win': None, 'lists': None},
                              'raw': {'win': None, 'lists': None},
                              'ref': {'win': None, 'lists': None}}
            
        datafilename = tkd.askopenfilename(defaultextension='.txt',
                                           filetypes       =[('all files', '.*'), ('text files', '.txt')],
                                           title           ='Select RAW DATA',
                                           initialdir      =r'F:\data\LC\ITF\XYS-CH\ch_eit_converted')
        if len(datafilename) == 0: return

        # check whether it is HPLC-DAD raw data converted from Agilent ChemStation
        tidx = datafilename.rfind('/d')
        if tidx==-1:
            tkm.showerror('Invalid Data File Selected',
                          'Currently only Agilent HPLC-DAD data is accepted!')
            return
        
        if 'rawdatafile' not in list(self.__dict__.keys()) or datafilename is not self.rawdatafile:
            self.rawdatafile=datafilename
            self.rawrtfile  =datafilename[:tidx]+'/t'+datafilename[tidx+2:]
            self.rawwvfile  =datafilename[:tidx]+'/w'+datafilename[tidx+2:]
            if not os.path.isfile(self.rawwvfile) or not os.path.isfile(self.rawrtfile):
                tkm.showerror('File Not Exist',
                              'No such wavelength or retention time file existed, please check it.'+\
                              '\nThis is probably caused by selecting incorrect raw data'+\
                              'file, or the absence of such file during data conversion.')
                return
            self.selectRefMethod(True)
    
    def selectRefMethod(self,rawinputTag):
        """ Select standard data set according the checked experimental method. """
        # "rawinputTag" is a tag for identifying whether this call is from
        # "rawDataLoad", if True, load raw data when drawing curves, if False,
        # load reference data as the call is from 'Load Reference Data' menu.
        self.rawinputTag = rawinputTag

        if self.selectwins['refmethod']['win'] is not None:
            self.selectwins['refmethod']['win'].attributes('-topmost',True)
            self.selectwins['refmethod']['win'].attributes('-topmost',False)
            return
        self.selectWinCreator('refmethod')

    def refDataLoad(self):
        """ Load reference data and corresponding information wavelength, retention
            time, marker retention time. """
        self.refdata = np.loadtxt(self.refdatafile)
        with open(self.refinfofile,'r') as f:
            for line in f:
                eqstr=line.find('=')
                if eqstr is not -1:
                    line=line.strip()
                    if line.startswith('MARKERRT'):
                        t  = line[eqstr+1:].split(';')
                        rts= []
                        for s in t:
                            rts.append([float(v) for v in s.split(' ')])
                        self.markerrt=rts
                    elif line.startswith('WVMAIN'):
                        self.currwv  =int(line[eqstr+1:])
                    elif line.startswith('TIME'):
                        self.refrt   =np.array([float(t) for t in line[eqstr+1:].split(' ')])
                    elif line.startswith('WAVELENGTH'):
                        self.refwaves=np.array([int(t) for t in line[eqstr+1:].split(' ')])
                    elif line.startswith('WVTHR'):
                        self.wvthr = int(line[eqstr+1:])
            # avoid reloading again...
            self.refredrawTag = False
    
    def drawCurves(self):
        """ Draw raw data and method data.
            Note: If standard data specified by the methods of raw data has been
                  loaded, ignore it, else update the curve of method data. """
        if 'rawdax' in list(self.__dict__.keys()):
            if self.rawinputTag:                       # this is from "rawDataLoad" call
                # initialization and memory collection
                del self.rawdata
                gc.collect()

                # this is required as different method will use different wavelength threshold,
                # if not updated accordingly, an error will raised.
                if self.refredrawTag:
                    del self.refdata
                    gc.collect()
                    # load and draw data
                    self.refDataLoad()
                    self.drawRefCurve()
                
                # load and draw data
                self.drawRawData()
                # perform MSCC analysis using current data to find markers
                self.markerFinder()
                
            if self.refredrawTag:
                del self.refdata
                gc.collect()
                # load and draw data
                self.refDataLoad()
                self.drawRefCurve()
            
        else: # Set up figures and plot curves when is the first time to load data.
            # stores wavelength selection text artists and indicators to identify whether
            # toolbars are activated
            self.wvtxt  =[None,None]
            self.toolids=[False, False]
            # load reference curve
            self.refDataLoad()
            # load reference data and corresponding information
            self.drawRawData()
            self.drawRefCurve()
            
            # draw as a canvas and curstomize toolbar
            self.canvas.show()
            self.figure.canvas.mpl_connect('pick_event', self.wvSelecter)
            # set cursor to hand when mouse moves over the text
            self.mvcid=self.figure.canvas.mpl_connect('motion_notify_event', OnHover(self.wvtxt))
            
            toolbar   =NavigationToolbar(self)
            toolbar.update()
            self.canvas._tkcanvas.pack(side='top', fill='both', expand=1)
            
            # perform MSCC analysis using current data to find markers
            self.markerFinder()
    
    def drawRawData(self):
        """ Load and draw raw data """
        if 'rawdax' in list(self.__dict__.keys()):
            self.rawdax.clear()
        else:
            self.rawdax = self.figure.add_subplot(2,1,1) 
        
        # load data
        rawrt  =np.loadtxt(self.rawrtfile)
        waves  =np.loadtxt(self.rawwvfile)
        rawdata=np.loadtxt(self.rawdatafile)[:,waves>=self.wvthr]

        texts  =['View Single Wavelength Chrom','Raw File: '+self.rawdatafile,'raw']
        mp, yuplim, text = figparams.set_figureparams(rawdata, rawrt, self.rawdax, texts)
        self.rawdax.plot(rawrt, rawdata/mp)
        self.rawxylims=[self.rawdax.get_xlim(),self.rawdax.get_ylim()]
        self.rawmp    =mp
        self.rawrt    =rawrt
        self.rawdata  =rawdata
        self.wvtxt[0] =text
        
        if 'rawdax' in list(self.__dict__.keys()): self.figure.canvas.draw()
    
    def drawRefCurve(self):
        """ Draw reference and customize the annotation which can be edited by user. """
        if 'refdax' in list(self.__dict__.keys()):
            self.refdax.clear()
        else:
            self.refdax = self.figure.add_subplot(2,1,2)
        
        # set up curves
        curve  =self.refdata[:,self.refwaves==self.currwv]
        texts  =['Wavelength: %d nm' % self.currwv,'Method: %s' % self.refmethod,'ref']
        mp, yuplim, text = figparams.set_figureparams(curve,self.refrt,self.refdax,texts)
        curve /=mp
        yuplim/=mp
        self.refdax.plot(self.refrt,curve)
        self.refdax.set_xlabel('Retention Time/min', fontdict={'size':12, 'fontname':'Times New Roman'})
        self.refxylims=[self.refdax.get_xlim(),self.refdax.get_ylim()]
        self.wvtxt[1] =text

        # find centre of marker peak for annotation
        cnter = []
        for mrt in self.markerrt:
            lidx=np.where(self.refrt<=mrt[0])[0][-1]
            idx =np.argmax(curve[(self.refrt>=mrt[0])&(self.refrt<=mrt[1])])
            cnter.append(lidx+idx)
        # annotate marker text to the curve
        arrowprops={'arrowstyle': "simple,tail_width=0.3", 'color': '#A9A9A9'}
        yhei=yuplim*0.1
        n   =0
        for site in cnter:
            n += 1
            textxy = (self.refrt[site],curve[site]+yhei)
            if textxy[1]>yuplim*0.9: textxy = (self.refrt[site]*1.05,yuplim*0.9)
            self.refdax.annotate('Marker %d' % n,xy       =(self.refrt[site],curve[site]),
                                                xycoords  ='data',
                                                xytext    =textxy,
                                                textcoords='data',
                                                size      =12,
                                                name      ='Times New Roman',
                                                va        ="center",
                                                ha        ="center",
                                                color     ='red',
                                                arrowprops=arrowprops)
        if 'refdax' in list(self.__dict__.keys()): self.figure.canvas.draw()
        
    def drawNewrefCurve(self,selectwv):
        """ Draw curve according to the selected wavelength after calling Listbox self.wvSelecter. """
        if selectwv is not self.currwv:
            self.currwv = selectwv
            self.drawRefCurve()

    def drawSingleWVCurve(self,selectwv):
        """ Raise new window for displaying the single wavelength chromatogram.
            To deal with multiple windows intelligently, all currently toplevel windows are stored
            in a list. If a window is closed, the corresponding toplevel instance is set to None. If
            new wavelength is selected for showing, the None in the window list is replaced by
            the new toplevel instance which shows the chromatogram of the wavelength, whereas
            if no None value occurs in the list, i.e. all windows are still opened, the list is
            appended to include newly opened toplevel instance.
        """
        if 'rwvdrawlist' not in list(self.__dict__.keys()):
            self.rwvdrawlist=[]
            self.rwcwins    =[]
        if selectwv in self.rwvdrawlist:
            idx = self.rwvdrawlist.index(selectwv)
            self.rwcwins[idx].attributes('-topmost',True)
            self.rwcwins[idx].attributes('-topmost',False)
            return

        # draw the single wavelength chromatogram in raised window
        win = tk.Toplevel()
        win.wm_title("Single Wavelength Chromatogram")
        
        figure=Figure(figsize=(6,3), facecolor='white', edgecolor='white')
        ax 	  =figure.add_subplot(111)
        curve =self.rawdata[:,self.refwaves==selectwv]
        # get parameters for tick setting
        texts  =['Current wavelength: %d nm' % selectwv,'','rswv']
        mp, yuplim, text = figparams.set_figureparams(curve,self.rawrt,ax,texts)

        # plot
        ax.plot(self.rawrt,curve/mp)
        ax.set_xlabel('Retention Time/min', fontdict={'size':12,'fontname':'Times New Roman'})
        
        canvas = FigureCanvas(figure, master=win)
        canvas.get_tk_widget().pack(side='top', fill='both', expand=1)
        canvas.show()
        
        toolbar = NavigationToolbar2TkAgg(canvas, win)
        toolbar.update()
        canvas._tkcanvas.pack(side='top', fill='both', expand=1)

        # get the index for the newly opened window
        if None in self.rwvdrawlist:
            idx = self.rwvdrawlist.index(None)
            self.rwvdrawlist[idx]=selectwv
            self.rwcwins[idx] 	 =win
        else:
            idx = len(self.rwvdrawlist)
            self.rwvdrawlist.append(selectwv)
            self.rwcwins.append(win)
        win.protocol("WM_DELETE_WINDOW", lambda: self.singleWVWinQuit(idx))

    def wvSelecter(self,event):
        """ Set up wavelength list for selection to show single wavelength chromatogram
            of reference and raw data. """
        label = event.artist.get_label()
        if self.selectwins[label]['win'] is not None:
            self.selectwins[label]['win'].attributes('-topmost',True)
            self.selectwins[label]['win'].attributes('-topmost',False)
            return
        self.selectWinCreator(label)
        
    def getIdx(self, call):
        """ Get indices from listbox, related to attributes 'wvSelecter' and 'selectRefMethod'. """
        index = self.selectwins[call]['lists'].curselection()
        if index:
            text = self.selectwins[call]['lists'].get(index)
            # if the operation is valid, close the window and set the corresponding values to be None
            self.selectwins[call]['win'].destroy()
            self.selectwins[call]['win']  =None
            self.selectwins[call]['lists']=None
            if call=='refmethod':
                self.getMethod(text)
            else:
                if call=='ref':
                    self.drawNewrefCurve(int(text))
                elif call=='raw':
                    self.drawSingleWVCurve(int(text))
    
    def getMethod(self, selectedMethod):
        """ Get method from self.getIdx. """
        if 'refmethod' in list(self.__dict__.keys()) and selectedMethod == self.refmethod:
            self.refredrawTag= False
        else:
            self.refredrawTag= True
            self.refmethod   = selectedMethod
            self.refdatafile = os.path.join(CURRENTLIBPATH,selectedMethod+'.txt')
            self.refinfofile = os.path.join(CURRENTLIBPATH,selectedMethod+'.info')
        self.drawCurves()
    
    def markerFinder(self):
        """ Multicomponent spectrum correlated chromatographic analysis (MSCC) """
        # set up dialogue for displaying the progress of MSCC
        l = len(self.markerrt)
        progresswin=tk.Toplevel()
        progresswin.title('Processing...')
        progresswin.attributes('-topmost',True)
        progresswin.resizable(width=False, height=False)
        txtvar=tk.StringVar()
        point =tk.IntVar()
        tk.Label(progresswin,textvariable=txtvar).pack(fill='x',side='top')
        tkinter.ttk.Progressbar(progresswin, orient  ='horizontal',
                                     length  =300,
                                     mode    ='determinate',
                                     variable=point,
                                     maximum =l).pack(fill='x',side='top')
        self.progresswin=progresswin
        self.txtvar     =txtvar
        self.point      =point

        # MSCC
        self.targetidx = []
        self.i = 0
        self.markerIter()

    def markerIter(self):
        """ MSCC iterator to find marker """
        if self.i is 0:
            self.i += 1
            self.txtvar.set('Processing %d of %d markers...' % (self.i, len(self.markerrt)))
            self.point.set(self.i)
            self.progresswin.after(10,self.markerIter)
        else:
            i         =self.i-1
            startidx  =np.where(self.rawrt>=self.markerrt[i][0]-RTERR)[0][0]
            sel_data  =self.rawdata[(self.rawrt>=self.markerrt[i][0]-RTERR)
                                   &(self.rawrt<=self.markerrt[i][1]+RTERR)]
            markerpeak=self.refdata[(self.refrt>=self.markerrt[i][0])&(self.refrt<=self.markerrt[i][1])]
            midx      =np.argmax(np.max(markerpeak,axis=1))
            rg        =min(int(midx/4),int((len(markerpeak)-midx)/4))
            validrange=[midx-rg, midx+rg]

            # perform MSCC
            idx       =mscc.mscc(sel_data,markerpeak,validrange)

            if idx:
                self.targetidx.append([self.rawrt[startidx+idx], np.max(sel_data[idx])/self.rawmp, i+1])
                
            # displaying the progress...
            self.i += 1
            self.txtvar.set('Processing %d of %d markers...' % (self.i, len(self.markerrt)))
            self.point.set(self.i)
            if i<len(self.markerrt)-1:
                self.progresswin.after(10,self.markerIter)
            else:
                self.progresswin.destroy()
                if len(self.targetidx)>0:
                    self.markerAssign(self.targetidx)
                return
        
    def markerAssign(self,idx):
        """ Assign the marker peak in compound chromatogram """
        arrowprops={'arrowstyle'     :"Fancy, head_length=.6, head_width=.8, tail_width=.4",
                    'color'          :'#A9A9A9',
                    'connectionstyle':"arc3,rad=-0.2",
                    'shrinkB'        :6}
        xys 	   = []
        axislim    = [self.rawdax.get_xlim(),self.rawdax.get_ylim()]
        maxchrom=np.max(self.rawdata,axis=1)/self.rawmp
        maxchrom[maxchrom>axislim[1][1]] = axislim[1][1]
        minchrom=np.min(self.rawdata,axis=1)/self.rawmp
        for i in range(len(idx)):
            x,y,r,xa,ya = figparams.set_textcoords(self.rawrt,maxchrom,minchrom,axislim,xys,idx[i])
            if xa is not None:
                arrowprops={'arrowstyle': "simple, head_length=.6, head_width=.6, tail_width=.3",
                            'color':      '#A9A9A9'}
                xy        =(xa,ya)
            else:
                arrowprops['connectionstyle']="arc3,rad=%3.1f" % r
                xy        =(idx[i][0],idx[i][1])
            
            self.rawdax.annotate('Marker %d' % idx[i][-1],xy        =xy,
                                                          xycoords  ='data',
                                                          xytext    =(x,y),
                                                          textcoords='data',
                                                          size      =12,
                                                          name      ='Times New Roman',
                                                          va        ="center",
                                                          ha        ="center",
                                                          color     ='red',
                                                          arrowprops=arrowprops)
            xys.append([x,y])
            
        self.figure.canvas.draw()
        
        # if the raw data has been loaded, and the number of methods is larger than 1
        # selection of reference methods for showing is set to be available
        if len(self.methods) > 1:
            self.menutools.entryconfig(0, state='normal')
        # set the menu "Generate report" available
        self.menutools.entryconfig(1, state='normal')

    def selectWinCreator(self,label):
        """ Create selection window for reference methods and wavelength selection """
        # set up parameters for corresponding label
        if label == 'refmethod':
            geometry='160x240+1+1'
            title   ='Method Selection'
            text    =DIAGTEXT['reftxt']
            args    ={'font': ('Times',10),
                      'fg': 'red', 'bg': 'white', 'height': 2,
                      'relief':'raised', 'justify': 'center'}
            lists   =self.methods
        else:
            geometry='120x300+3+3'
            title   ='Wavelength Selection'
            text    ='Wavelength'
            args    ={'font': ('Times',10),
                      'fg': 'red', 'bg': 'white', 'height': 1, 'relief':'raised'}
            lists   =self.refwaves
            
        checkwin = tk.Toplevel()
        checkwin.geometry(geometry)
        checkwin.title(title)
        checkwin.resizable(width =False, height=False)
        checkwin.protocol('WM_DELETE_WINDOW',lambda:self.selectWinQuit(label))
        tk.Label(checkwin, text=text, **args).pack(side='top',fill='x')
        
        scrollbar = tk.Scrollbar(checkwin)
        listbox   = tk.Listbox(checkwin, relief ='sunken', cursor='hand2')
        scrollbar.config(command=listbox.yview)
        scrollbar.pack(side='right', fill='y')
        listbox.pack(side='left', expand=1, fill='both')
        listbox.config(yscrollcommand=scrollbar.set, selectmode='single')
        for elements in lists: listbox.insert(tk.END,elements)

        listbox.bind('<Double-1>',(lambda event, call=label: self.getIdx(call)))
        self.selectwins[label]['win']  =checkwin
        self.selectwins[label]['lists']=listbox

    def selectWinQuit(self,label):
        """ Close the wavelength selection window labelled by 'label' """
        self.selectwins[label]['win'].destroy()
        self.selectwins[label]['win']  =None
        self.selectwins[label]['lists']=None

    def singleWVWinQuit(self,index):
        """ Close the single wavelength chromatogram window corresponding to index """
        self.rwcwins[index].destroy()
        self.rwcwins[index]    =None
        self.rwvdrawlist[index]=None

    def forResultsGenerator(self):
        """ Call class ReportGenerator to generate report window """
        idx = self.rawdatafile.rfind('/d')
        resultsinfo = {'markerrt'  :self.markerrt,
                       'targetidx' :self.targetidx,
                       'methodname':self.refmethod,
                       'rawfile'   :self.rawdatafile[idx+2:]}
        ReportGenerator(resultsinfo)

    def forLibConstructor(self):
        """ Call class LibConstructor to construct method library """
        libs = LibConstructor()
        self.methods = libs.methods
        if len(self.methods)>1:
            print(self.methods)
            self.menutools.entryconfig(0, state='normal')
        
    def openDoc(self):
        os.system('start '+r'F:\Analysis\Python\useful_tools\tkColorCharts.png')
        
    def _quit(self):
        if tkm.askyesno('Verify quit', 'Are you sure you want to quit?'):
            self.root.destroy()
        

class LibConstructor(object):
    """ Construct library of reference data. The library is a folder located in
		same path of componentMatcher. """
    def __init__(self):
        self.methods= get_methodlist()
        self.loadMethodData()
        
    def loadMethodData(self):
        """ Load method data for library construction. """
        datafilename = tkd.askopenfilename(defaultextension='.txt',
                                           filetypes       =[('all files', '.*'), ('text files', '.txt')],
                                           title           ='Select Reference DATA')
        if len(datafilename)==0: return
        
        tidx  =datafilename.rfind('/d')
        rtfile=datafilename[:tidx]+'/t'+datafilename[tidx+2:]
        wvfile=datafilename[:tidx]+'/w'+datafilename[tidx+2:]
        if not os.path.isfile(wvfile) or not os.path.isfile(rtfile):
            tkm.showerror('File Not Exist',
                          'No such wavelength file existed, please check it.'+\
                          '\nThis is probably caused by selecting incorrect raw data'+\
                          'file, or the absence of such file after data conversion.')
            return
        self.refdata  =np.loadtxt(datafilename)
        self.refwaves =np.loadtxt(wvfile)
        self.refrt    =np.loadtxt(rtfile)
        self.currminwv=np.min(self.refwaves)
        self.dfname   =datafilename

        self.paramInputDlg()
        self.drawRefCurves()

    def paramInputDlg(self):
        """ Input dialogue for method parameters input for library construction. """
        
        # format parameter for input name
        argsm ={'font': ('Times',12,'bold'), 'anchor': 'w'}
        # format parameter for annotation of input name
        argsa ={'font': ('Times',10), 'anchor': 'nw', 'fg': '#2E8B57', 'justify': 'left'}
        # texts
        texts = [['Method Name:','nameanno'],
                 ['Marker RT:','markerrtanno'],
                 ['Wavelength:','waveanno']]
        packs ={'side': 'top', 'expand': 1, 'fill': 'x'}
        
        # set up window and parameters of window
        win = tk.Toplevel()
        win.bind('<Return>',(lambda event: self.fetchEntry))
        win.title('Input Method Data Paramters...')
        win.resizable(width=False, height=False)
        
        # add figure window in the parameter input dialog
        figure =Figure(figsize=(8,3), facecolor='white', edgecolor='white')
        
        canvas =FigureCanvas(figure, master=win)
        canvas.get_tk_widget().pack(side='top', fill='both', expand=1)
        canvas.show()
        toolbar=NavigationToolbarInLibFig(canvas, win)
        toolbar.update()
        canvas._tkcanvas.pack(side='top', fill='both', expand=1)

        # add the entry widgets for parameter inputs
        inputs=[]
        for i in range(len(texts)):
            tk.Label(win, text=texts[i][0], **argsm).pack(**packs)
            tk.Label(win, text=DIAGTEXT[texts[i][1]], **argsa).pack(**packs)
            ent = tk.Entry(win)
            ent.pack(**packs)
            inputs.append(ent)
            
        tk.Button(win,text='OK',command=self.fetchEntry,cursor='hand2').pack(side='right')
        win.attributes('-topmost',True)
        win.attributes('-topmost',False)
        self.paramwin=win
        self.figure  =figure
        self.entries =inputs

    def drawRefCurves(self):
        """ Display the selected reference method data for facilitating specification of parameters
            such as retention times of markers and threshold of wavelength. The wavelength threshold
            is used to eliminate the influence of chromatographic conditions which always produce
            serious baseline distortion. """

        ax=self.figure.add_subplot(111)
        # plot
        ax.plot(self.refrt,self.refdata[:,self.refwaves>=self.currminwv])
        ax.set_position([0.078,0.15,0.9,0.76])
        ax.set_xlabel('Retention Time/min', fontdict={'size':12,'fontname':'Times New Roman'})
        ax.tick_params(labelsize=10)
        ax.text(0.66,0.92,'Click to SET wavelength threshold',
                          fontname ='Times New Roman',
                          color    ='r',
                          size     =12,
                          transform=ax.transAxes,
                          bbox     ={'ec':'k', 'fc':'none', 'boxstyle':'round,pad=.2'},
                          picker   =True)
        ax.text(-0.002,1.012,'Ref file name: %s' % self.dfname,fontname='Times New Roman',
                             color    ='r',
                             size     =10,
                             transform=ax.transAxes)
        self.wvtinfo=ax.text(0.64,1.02,'Current wavelength threshold: %d nm' % self.currminwv,
                                       fontname ='Times New Roman',
                                       transform=ax.transAxes,
                                       size     =12,
                                       color    ='g')
        
        self.figure.canvas.mpl_connect('pick_event', lambda event: self.wvSelecter())
        self.axes=ax

    def wvSelecter(self):
        """ Select wavelength threshold of current reference method data """
        args    ={'font': ('Times',10),'fg': 'red', 'bg': 'white', 'height': 1, 'relief':'raised'}
        waves   =self.refwaves[self.refwaves<=280]
            
        checkwin = tk.Toplevel()
        checkwin.geometry('120x300+3+3')
        checkwin.title('Wavelength Selection')
        checkwin.resizable(width =False, height=False)
        tk.Label(checkwin, text='Wavelength', **args).pack(side='top',fill='x')
        
        scrollbar = tk.Scrollbar(checkwin)
        listbox   = tk.Listbox(checkwin, relief ='sunken', cursor='hand2')
        scrollbar.config(command=listbox.yview)
        scrollbar.pack(side='right', fill='y')
        listbox.pack(side='left', expand=1, fill='both')
        listbox.config(yscrollcommand=scrollbar.set, selectmode='single')
        for wv in waves: listbox.insert(tk.END,wv)

        listbox.bind('<Double-1>', self.getIdx)
        checkwin.attributes('-topmost',True)
        checkwin.attributes('-topmost',False)
        self.selectwin=checkwin
        self.listbox  =listbox

    def getIdx(self,event):
        """ Get the wavelength """
        index = self.listbox.curselection()
        if index:
            text = self.listbox.get(index)
            # if the operation is valid, close the window and set the corresponding values to be None
            self.selectwin.destroy()
            self.selectwv = int(text)
            if self.selectwv is self.currminwv:
                return
            self.updateRefPlot()

    def updateRefPlot(self):
        """ Update the reference method figure after specifying the wavelength threshold. """        
        if self.selectwv < self.currminwv:
            # add new chromatograms with wavelength less than currently specified wavelength
            # threshold
            curves = self.refdata[:,(self.refwaves>=self.selectwv)&(self.refwaves<self.currminwv)]
            lines = self.axes.plot(self.refrt,curves)
            self.axes.lines[:] = self.axes.lines[-len(lines):]+self.axes.lines[:-len(lines)]
        else:
            nlines = ((self.refwaves<self.selectwv) & (self.refwaves>=self.currminwv)).sum()
            del self.axes.lines[:nlines+1]

        # reset y limits
        self.axes.relim()
        self.axes.autoscale_view()
        # reset text
        self.wvtinfo.set_text('Current wavelength threshold: %d nm' % self.selectwv)
        # update figure
        self.figure.canvas.draw()
        # update current wavelength threshold
        self.currminwv = self.selectwv
    
    def fetchEntry(self):
        """ Fetch the entries and write to 'info' file """
        F=np.ones(len(self.entries),dtype=bool)
        n=0
        for ent in self.entries:
            if len(ent.get().strip())==0:
                F[n]=False
            n += 1
        if not any(F): return
        
        if self.isValidEntry():
            name=self.entries[0].get()
            if name in self.methods:
                c = tkm.askyesno('Warning',DIAGTEXT['namewarnmsg'],icon='warning')
                # Set the parameter window the topmost for re-input.
                self.paramwin.attributes('-topmost',True)
                self.paramwin.attributes('-topmost',False)
                if c: self.writeInfo(name)
            else:
                self.writeInfo(name)
    
    def writeInfo(self,filename):
        """ Write method parameters into info file. """
        refdata      =np.loadtxt(self.dfname)[:,self.refwaves>=self.currminwv]
        self.refwaves=self.refwaves[self.refwaves>=self.currminwv]
        # write to .info file
        fullinfoname = os.path.join(CURRENTLIBPATH,filename+'.info')
        # create the lib folder if not exist.
        try:
            os.makedirs(CURRENTLIBPATH)
        except OSError:
            if not os.path.isdir(CURRENTLIBPATH): raise
        
        with open(fullinfoname,'w') as f:
            for i in range(len(self.entries)):
                string = self.entries[i].get()
                if string.endswith(';'): string = string[:-1]
                f.write(DIAGTEXT['libinfo'][i]+string+'\n')
                
            f.write(DIAGTEXT['libinfo'][i+1]+'%d\n' % self.currminwv)
            
            f.write(DIAGTEXT['libinfo'][i+2])
            for value in self.refrt: f.write('%f ' % value)
            
            f.write('\n'+DIAGTEXT['libinfo'][i+3])
            for value in self.refwaves: f.write('%d ' % value)
        self.paramwin.destroy()
        
        # save data to the lib file
        fulldataname = os.path.join(CURRENTLIBPATH,filename+'.txt')
        np.savetxt(fulldataname,refdata,fmt='%f')
        
        self.methods.append(filename)
    
    def isValidEntry(self):
        """ Check whether the input parameters for specefying library data are valid """
        c = True
        if not self.validNameCheck(self.entries[0].get()):
            tkm.showerror('Invalid Name','Method name must not be empty and be all valid '+\
                                         'characters for defining a file name.')
            c = False
        elif not self.markerRTCheck(self.entries[1].get()):
            tkm.showerror('Invalid Input','Invalid inputs for specifying marker retention time, '+\
                                          'please check it!\nTips: This is probably caused by '+\
                                          'incorrect format or time range specified for a marker.')
            c = False
        elif not self.selectiveWVCheck(self.entries[2].get()):
            tkm.showerror('Invalid Input','The wavelength selected for fingerprint showing must '+\
                                          'be an integer between %d and %d' %\
                                          (self.refwaves[0],self.refwaves[-1]))
            c = False
        elif not self.markerRTWarning(self.entries[1].get()):
            c = False
            
        if not c:
            # Set the parameter window the topmost for re-input.
            self.paramwin.attributes('-topmost',True)
            self.paramwin.attributes('-topmost',False)
            return False
        return True
            
    def validNameCheck(self,string):
        """ Check whether the input method name is valid as this is also used as its lib file name. """
        if len(string.strip()) == 0:
            return False
        else:
            try:
                open(string,'w').close()
                os.remove(string)
                return True
            except IOError:
                return False
    
    def markerRTCheck(self,string):
        """ Check the format of input retention times of markers """
        string = string.strip()
        if string.endswith(';'): string=string[:-1]
        if not string: return False
            
        times=[s for s in string.split(';')]
        n=0
        for time in times:
            t =[s for s in time.split(' ') if s and not s.isspace()]
            for j in t:
                try:
                    float(j)
                    n += 1
                except ValueError:
                    return False
            if n != 2:
                return False
            if float(time.split(' ')[1]) <= float(time.split(' ')[0]):
                return False
            n=0
            
        return True
    
    def selectiveWVCheck(self,string):
        """ Check the input selective wavelength for fingerprint """
        if not string.strip(): return False
        try:
            wv = int(string)
        except ValueError:
            return False
        
        if wv<self.refwaves[0] or wv>self.refwaves[-1]:
            return False
        else:
            return True

    def markerRTWarning(self,string):
        """ Check the retention time specified for markers. If any of the time input less then
            5 min, a warning will be raised for checking. """
        string = string.strip()
        if string.endswith(';'): string=string[:-1]
        if not string: return False
        
        times=[s for s in string.split(';')]
        t 	 = []
        for time in times:
            t.append([float(s) for s in time.split(' ') if s and not s.isspace()])
        t.sort()
        if t[0][0] <= 5:
            a = tkm.askyesno('Time Warning','Retention times specified for markers are less'+\
                                            ' then 5 min!\nAre you sure?',
                                            icon='warning')
            if not a:
                return False
        
        return True
    

class ReportGenerator(object):
    """ Display and save results
           Input:
               datainfo: data information required for displaying and saving results, which contains
                         marker retention times, retention time of raw data, matched information.
                         Currently, this is stored in a dictionary. """
    def __init__(self,datainfo):
        self.mkrt = []
        for time in datainfo['markerrt']:
            self.mkrt.append(round((time[0]+time[1])/2.,3))
        self.minfo=datainfo['targetidx']
        self.mkidx=[]
        for i in range(len(self.minfo)):
            self.mkidx.append(self.minfo[i][-1])
        self.refmethod=datainfo['methodname']
        self.rawfile  =datainfo['rawfile']

        self.makeShowWin()
        self.showText()

    def makeShowWin(self):
        """ Construct main window for showing results """
        showin  =tk.Toplevel()
        showin.geometry('420x300+100+100')
        framewin=tk.Frame(showin,height=1,bd=.5)
        framewin.pack(side='top',fill='both',expand=1)
        sbar    =tk.Scrollbar(framewin)
        textwin =tk.Text(framewin, relief='sunken')
        sbar.config(command=textwin.yview)
        textwin.config(yscrollcommand=sbar.set)
        sbar.pack(side='right', fill='y')
        textwin.pack(side='left', expand=1, fill='both')
        self.textwin = textwin
        tk.Button(showin,text='Save',command=self.saveToFile, cursor='hand2').pack(side='right')

    def showText(self):
        """ Display results """
        self.textwin.insert('1.0','Method Name: '+self.refmethod+'\n')
        self.textwin.insert('2.0','Raw File:'+' '*11+self.rawfile+'\n')
        self.textwin.insert('3.0','Statistics:'+' '*10+str(len(self.minfo))+' of total '+\
                                  str(len(self.mkrt))+' markers are found\n')
        self.textwin.insert('4.0','\nDETAIL INFORMATION:\n')
        self.textwin.insert('6.0','Marker ID\t\tMatched\t\tRaw RT/min\t\tRef RT/min\n')
        n = 6
        for i in range(len(self.mkrt)):
            n+=1
            if i+1 in self.mkidx:
                idx = self.mkidx.index(i+1)
                self.textwin.insert(str(n)+'.0',str(i+1)+'\t\tY\t\t'+\
                                                str(round(self.minfo[idx][0],3))+'\t\t'+\
                                                str(self.mkrt[i])+'\n')
            else:
                self.textwin.insert(str(n)+'.0',str(i+1)+'\t\tN\t\t-\t\t'+str(self.mkrt[i])+'\n')
        self.textwin.config(state='disabled',font=('Times',10))
                
    def saveToFile(self):
        """ Save the results to file """
        file = tkd.asksaveasfile(mode='w', defaultextension=".txt",
                                           filetypes=[('all files', '.*'), ('text files', '.txt')],
                                           title='Save results')
        if file is None: return
        file.write('Method Name: '+self.refmethod+'\n')
        file.write('Raw File: '+self.rawfile+'\n')
        file.write('Statistics: ' +str(len(self.minfo))+' of total '+\
                   str(len(self.mkrt))+' markers are found\n')
        file.write('\nDETAIL:\n')
        file.write('Marker ID\t\tMatched\t\tRaw RT/min\t\tRef RT/min\n')
        for i in range(len(self.mkrt)):
            if i+1 in self.mkidx:
                idx = self.mkidx.index(i+1)
                file.write(str(i+1)+'\t'*4+'Y'+'\t'*4+str(round(self.minfo[idx][0],3))+\
						   '\t'*4+str(self.mkrt[i])+'\n')
            else:
                file.write(str(i+1)+'\t'*4+'N'+'\t'*4+'-'+'\t'*4+str(self.mkrt[i])+'\n')
        file.close()


def main():
    root = tk.Tk()
    root.title("componentMatcher")
    MainGUI(root)
    root.mainloop()
    
if __name__ == '__main__':
    main()
