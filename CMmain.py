# -*- coding: utf-8 -*-
"""
Main GUI of componentMatcher. componentMatcher is a simple GUI for finding common
components from HPLC-DAD fingerprints of TCM compound and single medicine according
to experimental condition defined by Hong Kong Chinese Materia Medica Standards
(HKCMMS) of corresponding single medicine. In current package, spectral correlative
chromatography (SCC) method is used to match HPLC-DAD fingerprint peaks derived
from TCM compound and single medicine. Prior to this, baseline correction is
performed.

This package is lisenced under the terms of Apache License, version 2.0.
Copyright to Nai-ping Dong, PolyU in Hong Kong, 2014.

E-mail: np.dong572@gmail.com
"""

from __future__ import division

import tkMessageBox as tkm
import tkFileDialog as tkd
import Tkinter as tk
import numpy as np
import ttk
import os
import gc
import CMio
import mscc
import numcomp
import figparams

from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg as FigureCanvas
from matplotlib.backends.backend_tkagg import NavigationToolbar2TkAgg
from matplotlib.backends.backend_tkagg import ToolTip
from matplotlib.backends.backend_tkagg import cursord

from aboutcm import aboutCM


# Set up dialog texts
DIAGTEXT    ={'reftxt'      :'Please select corresponding\nexperimental method:',
              'markerrtanno':'Retention times of markers, must contain two time points each '+\
                             'marker: start and end time of elution, separated by space; if\n'+\
                             'several markers existed, semicolons ";" must be used as '+\
                             'delimiters between markers. e.g., 24.9 25.3;37.6 38.05.',
              'nameanno'    :'Name of method, single medicine name or its abbreviation '+\
                             'is recommended since this is also used as the name in method '+\
                             'list\nfor selection when you analyze the compound raw data.',
              'refmrtanno'  :'Retention time of reference marker. The time where highest\n'+\
                             'intensity locates. If not exist, leave it empty.',
              'waveanno'    :'Wavelength for showing fingerprint of the medicine.\n'+\
                             'Must be an integer.',
              'namewarnmsg' :'The method name has been assigned,\nare you sure you want '+\
                             'to overwrite it?',
              'libinfo'     :['# Method name\nNAME=',
                              '# Marker retention times\nMARKERRT=',
                              '# Retention time of reference marker, used to '+\
                                'calculate relative retention time\nREFMRT=',
                              '# Selected wavelength for fingerprint showing\nWVMAIN=',
                              '# Minimum wavelength used for matching makers. Generally, '+\
                                'this is used to eliminate serious baseline distortion '+\
                                'generated by chromatographic conditions.\nWVTHR=',
                              '# Retention time of fingerprint method\nTIME=',
                              '# Wavelength of fingerprint method\nWAVELENGTH='],
                             }
# Set up parameters for configuration of popup selection window for different applications
PARAMS        ={'method':{'geometry':'160x240+1+1', 'title':'Method Selection',
                          'text'    :DIAGTEXT['reftxt'],
                          'args'    :{'font': ('Times',10), 'fg': 'red', 'bg': 'white',
                                      'height': 2, 'relief':'raised', 'justify': 'center'}},
                'wvsel' :{'geometry':'120x300+3+3', 'title':'Wavelength Selection',
                          'text'    :'Wavelength',
                          'args'    :{'font': ('Times',10), 'fg':'red', 'bg':'white',
                                      'height':1, 'relief':'raised'}}}
# Set up global parameters
CURRENTLIBPATH=os.path.join(os.getcwd(),'lib')        # Lib path
# Relative retention time tolerance to find maker peaks when reference
# marker is found
RRTERR        =0.09
# Allowed retention time tolerance: 5% in first 30 min and 10% in the latter time
RTERR         =[.05, .1]
DEFAULTCURSOR =cursord[1]


# ----------------------------------------------------------------------------------------------
## open document file
def opendoc(self):
    """ Open document """
    os.system('start '+r'F:\Analysis\Python\useful_tools\tkColorCharts.png')

# ----------------------------------------------------------------------------------------------
## read method list in lib directory
def get_methodlist():
    """ Read method list in lib directory """
    expmethods=[]
    if not os.path.isdir(CURRENTLIBPATH): return expmethods
     
    files     =os.listdir(CURRENTLIBPATH)
    for name in files:
        if name.endswith('.info'):
            expmethods.append(name.split('.')[0])
    return expmethods


# ----------------------------------------------------------------------------------------------
## set hand cursor when mouse moves over the activated text
class OnHover(object):
    """ Set hand cursor when mouse moves over the text that has callbacks
        in MainGUI.
        Input:
            artist  text artist where hand cursor set
    """
    def __init__(self, artists, cursor=u'hand2'):
        self.artist=artists
        self.cursor=cursor
        self.fig   =[artist.axes.figure for artist in artists]

    def __call__(self, event):
        for artist in self.artist:
            inside, _ = artist.contains(event)
            if inside:
                break
        
        if inside:
            cursord[1]= self.cursor
        else:
            cursord[1]= DEFAULTCURSOR
            
        for fig in self.fig:
            fig.canvas.toolbar.set_cursor(1)


# ----------------------------------------------------------------------------------------------
## customize navigation toolbar for MainGUI
class NavigationToolbar(NavigationToolbar2TkAgg):
    """ Navigation toolbar of MainGUI. """
    # tool items of tool bar
    toolitems=(
               (u'Home', u'Reset to original view', u'home', u'home'),
               (u'Pan', u'Pan axes with left mouse, zoom with right', u'move', u'pan'),
               (u'Zoom', u'Zoom figure to rectangle', u'zoom_to_rect', u'zoom')
               )
    
    def __init__(self,parent):
        self.parent =parent
        self.refdax =parent.refax.refdax
        self.rawdax =parent.rawdax
        self.toolids=parent.toolids
        self.figure =parent.figure
        self.mvcid  =parent.mvcid
        NavigationToolbar2TkAgg.__init__(self, parent.canvas, parent.root)
        
    def home(self):
        """ Redefine home for navigation toolbar of matplotlib, as the default function will
            produce unexpected figure. As posted in http://stackoverflow.com/q/27906253/3003072
        """
        refxlow, refxup     =self.refdax.get_xbound()
        refylow, refyup     =self.refdax.get_ybound()
        rawxlow, rawxup     =self.rawdax.get_xbound()
        rawylow, rawyup     =self.rawdax.get_ybound()
        refxylims,rawxylims =self.parent.refax.refxylims,self.parent.rxylims
        if refxlow is not refxylims[0][0] or refxup is not refxylims[0][1]:
            self.refdax.set_xlim(refxylims[0])
            self.refdax.set_ylim(refxylims[1])
            self.refdax.figure.canvas.draw_idle()
        
        if rawxlow is not rawxylims[0][0] or rawxup is not rawxylims[0][1]:
            self.rawdax.set_xlim(rawxylims[0])
            self.rawdax.set_ylim(rawxylims[1])
            self.rawdax.figure.canvas.draw_idle()

    def zoom(self):
        """ Redefine zoom function for navigation toolbar of matplotlib """
        # set label to identify whether toolbar is activated
        if self.toolids[1]: # activated but now deactivated
            wvtxt           =self.parent.wvtxt
            self.mvcid      =self.figure.canvas.mpl_connect('motion_notify_event', OnHover(wvtxt))
            self.toolids[1] =False
        else:
            self.figure.canvas.mpl_disconnect(self.mvcid)
            self.toolids[1] = True
        NavigationToolbar2TkAgg.zoom(self)

    def pan(self):
        """ Redefine pan function for navigation toolbar of matplotlib """
        if self.toolids[0]: # activated but now deactivated
            wvtxt           =self.parent.wvtxt
            self.mvcid = self.figure.canvas.mpl_connect('motion_notify_event', OnHover(wvtxt))
            self.toolids[0] = False
        else:
            self.figure.canvas.mpl_disconnect(self.mvcid)
            self.toolids[0] = True
        NavigationToolbar2TkAgg.pan(self)


# ----------------------------------------------------------------------------------------------
## customize navigation toolbar for lib constructor interface
class NavigationToolbarInLibFig(NavigationToolbar2TkAgg):
    """ Reset the location of navigation toolbar in lib constructor interface as the default
        location is at the buttom of the interface. This can be achieved by modifying the attribute
        _init_toolbar of the original NavigationToolbar2 calss """
    toolitems=(
               ('Home', 'Reset original view', 'home', 'home'),
               ('Pan', 'Pan axes with left mouse, zoom with right', 'move', 'pan'),
               ('Zoom', 'Zoom to rectangle', 'zoom_to_rect', 'zoom'),
               ('Save', 'Save the figure', 'filesave', 'save_figure')
               )
    def _init_toolbar(self):
        xmin, xmax = self.canvas.figure.bbox.intervalx
        height, width = 50/20, (xmax-xmin)/20
        tk.Frame.__init__(self, master=self.window,
                          width=int(width), height=int(height),
                          borderwidth=1)

        self.update()  # Make axes menu

        for text, tooltip_text, image_file, callback in self.toolitems:
            button = self._Button(text=text, file=image_file,command=getattr(self, callback))
            ToolTip.createToolTip(button, tooltip_text)

        self.message = tk.StringVar(master=self)
        self._message_label = tk.Label(master=self, textvariable=self.message)
        self._message_label.pack(side=tk.RIGHT)
        self.pack(side=tk.TOP, fill=tk.X)


# ----------------------------------------------------------------------------------------------
## Popup for selection
class Selector(object):
    """ Selector window to select variable for further operation to show the information
        required by the user.
        Inputs:
            master  root of the toplevel widget
            params  a dictionary contains the parameters that configure the selection
                    window
        Outputs:
            selected text """
    def __init__(self, root, params):
        self.root  =root
        self.params=params
        self.winCreator()

    def winCreator(self):
        """ Create selection window in which information are listed """
        top = tk.Toplevel()
        top.protocol("WM_DELETE_WINDOW", self.selectWinQuit)
        top.transient(self.root) # Make Toplevel a subwindow on the root window
        top.grab_set() # Make user only able to interact with the Toplevel as long as it's opened
        
        top.geometry(self.params['geometry'])
        top.title(self.params['title'])
        top.resizable(width =False, height=False)
        
        tk.Label(top, text=self.params['text'], **self.params['args']).pack(side='top',fill='x')
        
        sb =tk.Scrollbar(top)
        lb =tk.Listbox(top, relief ='sunken', cursor='hand2')
        sb.config(command=lb.yview)
        sb.pack(side='right', fill='y')
        lb.pack(side='left', expand=1, fill='both')
        lb.config(yscrollcommand=sb.set, selectmode='single')
        for element in self.params['lists']: lb.insert(tk.END,element)

        lb.bind('<Double-1>',lambda event: self.getValue())
        self.top=top
        self.lb =lb

        self.root.wait_window(top) # Wait until the Toplevel closes before continuing

    def getValue(self):
        """ Get indices from listbox, related to attributes 'wvSelecter' and 'selectRefMethod'. """
        index = self.lb.curselection()
        if index:
            self.selectedvalue = self.lb.get(index)
            # if the operation is valid, close the window and set the corresponding
            # values to be None
            self.selectWinQuit()

    def value(self):
        """ return the selected value """
        return self.selectedvalue
        
    def selectWinQuit(self):
        """ Close the wavelength selection window labelled by 'label' """
        if 'selectedvalue' not in self.__dict__.keys():
            self.selectedvalue=None
        self.top.destroy()


# ----------------------------------------------------------------------------------------------
## MAIN GUI
class MainGUI(object):
    """ Main GUI of componentMatcher """
    def __init__(self,root):
        root['bg'] ='white'
        CreateMainWin(root)
        

# ----------------------------------------------------------------------------------------------
## CREATE MAIN WINDOW
class CreateMainWin(object):
    """ Create main window of the package """
    def __init__(self,root):
        self.root       =root
        self.makeMenu()
        self.mainFigureWin()
    
    def makeMenu(self):
        topmenus = tk.Menu(self.root)
        self.root.config(menu=topmenus)
        
        menufile = tk.Menu(topmenus, tearoff=False)
        menufile.add_command(label='Load Data', command=self.drawRawCurves, underline=0)
        menufile.add_command(label='Quit',      command=self._quit,       underline=0)
        topmenus.add_cascade(label='File',      menu=menufile,            underline=0)
        
        menutool = tk.Menu(topmenus, tearoff=False)
        menutool.add_command(label    ='Load Reference',
                             command  =self.drawRefCurves,
                             state='disabled',
                             underline=0)
        menutool.add_command(label    ='Generate Report',
                             command  =self.forResultsGenerator,
                             state='disabled',
                             underline=0)
        menutool.add_command(label    ='Add Reference',
                             command  =self.forLibConstructor,
                             underline=0)
        topmenus.add_cascade(label='Tool',    menu=menutool,       underline=0)
        self.menutools = menutool
        
        menuhelp = tk.Menu(topmenus, tearoff=False)
        menuhelp.add_command(label='CM Docs', command=opendoc,underline=0)
        menuhelp.add_separator()
        menuhelp.add_command(label='About CM',command=aboutCM,underline=0)
        topmenus.add_cascade(label='Help',    menu=menuhelp,       underline=0)
    
    def mainFigureWin(self):
        self.figure = Figure(figsize=(10,6), facecolor='white', edgecolor='white')
        self.canvas = FigureCanvas(self.figure, master=self.root)
        self.canvas.get_tk_widget().pack(side='top', fill='both', expand=1)

    def drawRawCurves(self):
        """ Draw raw chromatograms """
        rawax = DrawRawCurves(self)
        if 'rawax' not in self.__dict__.keys():
            self.rawax = rawax

    def drawRefCurves(self):
        """ Draw new reference method chromatogram """
        methods=get_methodlist()
        params =PARAMS['method']
        params['lists']=methods
        sl     =Selector(self.root, params)
        method =sl.value()
        
        if method is None: return

        if method != self.rawax.method:
            self.rawax.method =method
            self.rawax.methods=methods
            
            del self.rawax.refax.refdata
            gc.collect()
            DrawRefCurve(self.rawax)

    def forResultsGenerator(self):
        """ Call class ReportGenerator to generate report window """
        ReportGenerator(self.rawax)

    def forLibConstructor(self):
        """ Call class LibConstructor to construct method library """
        LibConstructor(self)
        
    def _quit(self):
        if tkm.askyesno('Verify quit', 'Are you sure you want to quit?'):
            self.root.destroy()


# ----------------------------------------------------------------------------------------------
## Load and draw the raw and reference curves.
class DrawRawCurves(object):
    """ Load and draw the raw data, and perform MSCC to find markers. Once the markers are
        found, label the markers in the data figure to show the corresponding peaks where
        markers belong to. """
    def __init__(self, parent):
        self.root    =parent.root
        if 'rawax' in parent.__dict__.keys():
            self=parent.rawax
        self.figure  =parent.figure
        self.canvas  =parent.canvas
        self.menutool=parent.menutools
        self.methods =get_methodlist()
        self.rawDataLoad()
        
    def rawDataLoad(self):
        """ Load raw data specified by user. If the raw data has been loaded, no
            subsequent analysis is performed. """
        if 'rawdax' not in self.__dict__.keys() and len(self.methods) is 0:
            tkm.showerror('Invalid operation',
                          'No method constructed in library!\nYou must '+\
                          'construct the method library first.')
            return
            
        dfname = tkd.askopenfilename(defaultextension='.txt',
                                     filetypes       =[('all files', '.*'), ('text files', '.txt')],
                                     title           ='Select RAW DATA',
                                     initialdir      =r'F:\data\LC\ITF\XYS-CH\ch_eit_converted')
        if len(dfname) == 0: return

        # check whether it is HPLC-DAD raw data converted from Agilent ChemStation
        tidx = dfname.rfind('/d')
        if tidx==-1:
            tkm.showerror('Invalid Data File Selected',
                          'Currently only Agilent HPLC-DAD data is accepted!')
            return

        if 'rawdax' not in self.__dict__.keys() or dfname != self.rfname:
            self.rfname   =dfname
            self.rtfile=dfname[:tidx]+'/t'+dfname[tidx+2:]
            self.wvfile=dfname[:tidx]+'/w'+dfname[tidx+2:]
            if not os.path.isfile(self.wvfile) or not os.path.isfile(self.rtfile):
                tkm.showerror('File Not Exist',
                              'No such wavelength or retention time file existed, please check it.'+\
                              '\nThis is probably caused by selecting incorrect raw data'+\
                              'file, or the absence of such file during data conversion.')
                return
            self.selectRefMethod()
    
    def selectRefMethod(self):
        """ Select standard data set according the checked experimental method. """
        params=PARAMS['method']
        params['lists']=self.methods
        sl    =Selector(self.root, params)
        method=sl.value()
        if method is None: return

        if 'method' not in self.__dict__.keys() or method != self.method:
            self.method =method
            # get the wavelength threshold
            refinfo     =os.path.join(CURRENTLIBPATH,self.method+'.info')
            with open(refinfo,'r') as f:
                for line in f:
                    if line.startswith('WVTHR'):
                        line      =line.strip()
                        eqstr     =line.find('=')
                        self.wvthr=int(line[eqstr+1:])
            self.drawCurves()
        else:   # if no new method is selected, only draw and processing formula data
            del self.rdata
            self.rawdax.clear()
            gc.collect()
            self.drawRawData()
            self.markerFinder()

    def drawCurves(self):
        """ Draw raw data and method data.
            Note: If standard data specified by the methods of raw data has been
                  loaded, ignore it, else update the curve of method data. """
        if 'rawdax' in self.__dict__.keys():
            # initialization and memory collection for robust running
            del self.rdata, self.refax.refdata
            self.rawdax.clear()
            gc.collect()
        
            # load and draw data
            self.drawRawData()
            DrawRefCurve(self)

        else:       # Set up figures and plot curves when is the first time to load data.
            # stores wavelength selection text artists and indicators to identify whether
            # toolbars are activated
            self.wvtxt  =[None,None]
            self.toolids=[False, False]

            self.rawdax =self.figure.add_subplot(2,1,1)
            # load and draw data
            self.drawRawData()
            self.refax =DrawRefCurve(self)
            
            # draw as a canvas and curstomize toolbar
            self.canvas.show()
            self.figure.canvas.mpl_connect('pick_event', self.wvSelecter)
            # set cursor to hand when mouse moves over the text
            self.mvcid=self.figure.canvas.mpl_connect('motion_notify_event', OnHover(self.wvtxt))
            
            toolbar   =NavigationToolbar(self)
            toolbar.update()
            self.canvas._tkcanvas.pack(side='top', fill='both', expand=1)
            
        # perform MSCC analysis using current data to find markers
        self.markerFinder()
    
    def drawRawData(self):
        """ Load and draw raw data """
        # load data
        rd, rt, wv=CMio.loadtxt(self.rfname, self.rtfile, self.wvfile)
        rd=rd[:,wv>=self.wvthr]
        wv=wv[wv>=self.wvthr]

        texts  =[u'View Single Wavelength Chrom',u'Raw File: '+self.rfname,'raw']
        mp, yuplim, text = figparams.set_figureparams(rd, rt, self.rawdax, texts)
        self.rawdax.plot(rt, rd/mp)
        self.rxylims =[self.rawdax.get_xlim(),self.rawdax.get_ylim()]
        self.rmp     =mp
        self.rt      =rt
        self.rdata   =rd
        self.wv      =wv
        self.wvtxt[0]=text

        if 'rawdax' in self.__dict__.keys(): self.figure.canvas.draw()

    def wvSelecter(self,event):
        """ Set up wavelength list for selection to show single wavelength chromatogram
            of reference and raw data and draw the curve. """
        params=PARAMS['wvsel']
        params['lists']=self.wv
        sl    = Selector(self.root, params)
        if sl.value() is None: return
        wv    =int(sl.value())

        # get the label of the event to indicate which text is clicked and draw the
        # corresponding curve
        label =str(event.artist.get_label())
        if label == 'ref':
            if wv is self.refax.currwv:
                return
            self.refax.currwv = wv
            self.refax.drawRefCurve()
        elif label == 'raw':
            self.drawSingleWVCurve(wv)
    
    def markerFinder(self):
        """ Multicomponent spectrum correlated chromatographic analysis (MSCC) """
        # resort the marker RT list to let the reference marker RT list at the first
        l       =len(self.refax.markerrt)
        self.mrtidx = [i+1 for i in xrange(l)] # indices for reserving initial order
        i=-1
        if self.refax.refmrt != 0:
            for rt in self.refax.markerrt:
                i+=1
                if rt[0]<=self.refax.refmrt<=rt[1]: break
            self.refax.markerrt.insert(0,self.refax.markerrt.pop(i))
            self.mrtidx.insert(0,self.mrtidx.pop(i))

        # retain the information for results report
        self.refmkidx=i
        self.ms   =np.zeros((l, self.rdata.shape[1]))
        self.rms  =np.zeros((l, self.rdata.shape[1]))
        self.nmk  =l # number of total markers
        self.rnmk =0 # number of markers found in formula data
        self.mkrt =[] # retention times of markers in method
        self.rmkrt=[] # retention times of markers in formula data
        self.rs   =[] # correlative curves
        self.stidx=[] # idx of start in formula data
        self.amt  =[] # ambiguity tag to check whether the marker is ambiguous
        self.ps   =[] # SVR curve, for peak detection
        self.fps  =[] # peak indicators which indicate whether the peak is assigned

        # set up dialogue for displaying the progress of MSCC
        progresswin=tk.Toplevel()
        progresswin.title('Processing...')
        progresswin.attributes('-topmost',True)
        progresswin.resizable(width=False, height=False)
        txtvar=tk.StringVar()
        point =tk.IntVar()
        tk.Label(progresswin,textvariable=txtvar).pack(fill='x',side='top')
        ttk.Progressbar(progresswin, orient  ='horizontal',
                                     length  =300,
                                     mode    ='determinate',
                                     variable=point,
                                     maximum =l).pack(fill='x',side='top')
        self.progresswin=progresswin
        self.txtvar     =txtvar
        self.point      =point

        # MSCC
        self.targetidx = []
        self.i = 0
        self.markerIter()

    def markerIter(self):
        """ MSCC iterator to find marker """
        if self.i is 0:
            self.i += 1
            self.txtvar.set('Processing %d of %d markers...' % (self.i, len(self.refax.markerrt)))
            self.point.set(self.i)
            self.progresswin.after(10,self.markerIter)
        else:
            i         =self.i-1
            markerpeak=self.refax.refdata[(self.refax.rt>=self.refax.markerrt[i][0])
                                          &(self.refax.rt<=self.refax.markerrt[i][1])]
            midx      =np.argmax(np.max(markerpeak,axis=1))
            rg        =min(int(midx/4),int((len(markerpeak)-midx)/4))
            validrange=[midx-rg, midx+rg]
            startidx  =np.where(self.refax.rt>=self.refax.markerrt[i][0])[0][0]
            self.mkrt.append(self.refax.rt[midx+startidx]) # retention time of marker
            
            if self.refax.markerrt[i][1]<=self.rt[-1]:
                # error tolerance
                if i==0 or not self.userrt:
                    currerr =RTERR[0] if self.refax.rt[midx+startidx]<=30. else RTERR[1]
                    currerr*=self.refax.rt[midx+startidx]
                    # retention time
                    currrt  =self.rt*1.
                    currmrt =self.refax.markerrt[i]
                else:   # relative retention time is used
                    currrt =self.rt/self.rt[self.targetidx[0][1]+self.stidx[0]]
                    currerr=RRTERR
                    currmrt=[t/self.refax.refmrt for t in self.refax.markerrt[i]]
                        
                # get the information of formula data
                startidx=np.where(currrt>=currmrt[0]-currerr)[0][0]
                sel_data=self.rdata[(currrt>=currmrt[0]-currerr)&(currrt<=currmrt[1]+currerr)]
                # perform MSCC
                idx, r, tag =mscc.mscc(sel_data,markerpeak,validrange)

                # svr curve and peak detection
                s =numcomp.svr(sel_data)
                ms=numcomp.smoother(s)
                p =numcomp.peakdetect(ms)
                self.ps.append(p)
                self.fps.append([False]*len(p))

                self.rs.append(r)
                self.stidx.append(startidx)
                self.amt.append(False)
                # extract marker spectra and retention time
                self.ms[i] =markerpeak[midx]
                self.rms[i]=sel_data[idx]
                self.targetidx.append([self.mrtidx[i], idx, None])
                if tag:
                    self.targetidx[-1][-1] =np.max(sel_data[idx])/self.rmp
                    self.rnmk+=1
            
            else:   # if the marker not in the range of retention time, ignore it
                tag=False
                self.rs.append(0)
                self.ps.append(0)
                self.fps.append(0)
                self.stidx.append(None)
                self.amt.append(False)
                self.targetidx.append([self.mrtidx[i], None, None])

            if i is 0:
                # this is reference marker, if is found in formula data, set use relative
                # retention time True
                self.userrt = True if tag and self.refax.refmrt>0 else False
            
            # displaying the progress...
            self.i += 1
            self.txtvar.set('Processing %d of %d markers...' % (self.i, len(self.refax.markerrt)))
            self.point.set(self.i)
            if i<len(self.refax.markerrt)-1:
                self.progresswin.after(10,self.markerIter)
            else:
                self.progresswin.destroy()
                if len(self.targetidx)>0:
                    # set the marker list to the original order
                    self.markerIdxRecheck()
                    self.markerCheck()
                    self.markerAssign(self.targetidx)
                # if no marker is found, generate report as well
                self.menutool.entryconfig(1, state='normal')
                return

    def markerIdxRecheck(self):
        """ Reorder the resulted index to the original order """
        if self.mrtidx[0] is not 1:
            self.targetidx.insert(self.mrtidx[0]-1,self.targetidx.pop(0))
            self.stidx.insert(self.mrtidx[0]-1,self.stidx.pop(0))
            self.mkrt.insert(self.mrtidx[0]-1,self.mkrt.pop(0))
            self.amt.insert(self.mrtidx[0]-1,self.amt.pop(0))
            self.fps.insert(self.mrtidx[0]-1,self.fps.pop(0))
            self.ps.insert(self.mrtidx[0]-1,self.ps.pop(0))
            self.rs.insert(self.mrtidx[0]-1,self.rs.pop(0))
            self.ms[:self.mrtidx[0]]=np.vstack((self.ms[1:self.mrtidx[0]],self.ms[0]))
            self.rms[:self.mrtidx[0]]=np.vstack((self.rms[1:self.mrtidx[0]],self.rms[0]))
            self.refax.markerrt.insert(self.mrtidx[0]-1,self.refax.markerrt.pop(0))

        # assign peaks to indicators
        for i in xrange(self.nmk):
            for j in xrange(self.nmk):
                if self.targetidx[i][-1] is not None and \
                   self.targetidx[j][-1] is not None and \
                   i!=j:
                    idxt=self.targetidx[j][1]+self.stidx[j]-self.stidx[i]
                    idx =[k for k in xrange(len(self.ps[i]))
                          if self.ps[i][k][0]<=idxt<=self.ps[i][k][2]]
                    for k in xrange(len(idx)):
                        self.fps[i][idx[k]]=True
            t =0. if self.stidx[i] is None else self.rt[self.stidx[i]+self.targetidx[i][1]]
            self.rmkrt.append(t)

    def markerCheck(self):
        """ Check the markers extracted previously """
        print self.ps
        f =[True]*self.nmk
        for i in xrange(self.nmk-1):
            if self.stidx[i] is None or not f[i]: continue
            
            psite=[]
            if self.targetidx[i][2] is not None:
                psite+=[p for p in self.ps[i] if p[0]<=self.targetidx[i][1]<=p[2]]
            
            if len(psite)>0:
                psite=[psite[0][0],psite[0][2],psite[1][2]] if len(psite)>1 else psite[0]
                psite=[p+self.stidx[i] for p in psite]
                curridx=[i]
                for j in xrange(i+1,self.nmk):
                    if self.targetidx[j][2] is not None:
                        if psite[0]<=self.targetidx[j][1]+self.stidx[j]<=psite[2]:
                            curridx.append(j)

                print curridx
                if len(curridx)>1:
                    didx   =[curridx[i]-curridx[i-1] for i in xrange(1,len(curridx))]
                    if didx.count(1)==len(didx): # if all are adjacent
                        ll =[len(self.rs[i]) for i in curridx]
                        self.markerIdxGet(curridx,ll)
                    else:
                        # if multiple markers are assigned to same peak, but another
                        # assignments exist between these markers
                        idxt =[j+1 for j in xrange(len(didx)) if didx[j]>1]
                        idxt+=[len(didx)]
                        for j in xrange(len(idxt)-1):
                            # get the index of inserted marker
                            idxi=curridx[idxt[j]-1]+1
                            rti =self.rt[self.targetidx[idxi][1]+self.stidx[idxi]]
                            if j==0: # only markers with RT less than second marker is considered
                                l=[]
                                for k in xrange(idxt[j]+1):
                                    dr =np.where(np.sign(np.diff(self.rs[curridx[k]]))==1)[0]
                                    l.append(len([t for t in dr
                                                  if self.rt[t+self.stidx[curridx[k]]]<rti]))
                                self.markerIdxGet(curridx[:idxt[j]],l)
                            else: # others are reassigned
                                for k in xrange(idxt[j]+1,idxt[j+1]+1):
                                    dr =np.where(np.sign(np.diff(self.rs[curridx[k]]))==1)[0]
                                    if rti>=self.rt[dr[-1]+self.stidx[curridx[k]]]:
                                        self.targetidx[curridx[k]][-1]=[None]
                                    else:
                                        l=next(m for m,v in enumerate(dr)
                                               if self.rt[v+self.stidx[curridx[k]]]>rti)
                                        minidx=np.argmin(self.rs[curridx[k]][l:])
                                        if np.min(self.rs[curridx[k]][l:])<=.3:
                                            m=self.rdata[l+minidx+self.stidx[curridx[k]]]/self.rmp
                                            self.targetidx[curridx[k]][1:]=[l+minidx, np.max(m)]
                                        else:
                                            self.targetidx[curridx[k]][-1]=None

                    for j in curridx:
                        self.amt[j]=True
                        f[j]       =False
            else:
                if self.targetidx[i][-1] is not None: self.targetidx[i][-1]=None
                    
    def markerIdxGet(self, idx, l):
        """ Get new indices. Currently only 3 markers are considered. But if more markers exit,
            3 markers with lowest correlative scores are extracted and other markers are set
            to None. """
        if len(idx)>3:
            sx  =sorted(range(len(idx)), key=lambda k: min(self.rs[idx[k]]))
            sdx =[sx.index(j) for j in xrange(len(sx))] # sorted index
            tidx=[idx[sdx.index(i)] for i in xrange(3)] # get the lowest number
            for i in xrange(3,len(idx)):
                idxt=idx(sdx.index(i))
                self.targetidx[idxt][1:] = [np.argmin(self.rs[idxt]), None]
            idx=tidx
        # get information for reassignment
        r     =[self.rs[idx[i]][:l[i]] for i in xrange(len(idx))]
        mkrt  =[self.refax.markerrt[i] for i in idx]
        stidx =[self.stidx[i] for i in idx]
        ps    =[self.ps[i] for i in idx]
        fps =[self.fps[i] for i in idx]
        nidx =mscc.commonpeakcheck(r, mkrt,stidx, ps, fps)
        print nidx

        for i in xrange(len(nidx)):
            self.targetidx[idx[i]][1:]=[np.argmin(r[i]), None] if nidx[i] is None \
                                        else [nidx[i]-self.stidx[idx[i]],
                                              np.max(self.rdata[nidx[i]])/self.rmp]
            self.rmkrt[idx[i]]        =self.rt[self.stidx[idx[i]]+self.targetidx[idx[i]][1]]
    
    def markerAssign(self,idxs):
        """ Assign the marker peak in compound chromatogram """
        arrowprops={'arrowstyle'     :"Fancy, head_length=.6, head_width=.8, tail_width=.4",
                    'color'          :u'#A9A9A9',
                    'connectionstyle':"arc3,rad=-0.2",
                    'shrinkB'        :6}
        xys 	   =[]
        axislim =[self.rawdax.get_xlim(),self.rawdax.get_ylim()]
        maxchrom=np.max(self.rdata,axis=1)/self.rmp
        maxchrom[maxchrom>axislim[1][1]] = axislim[1][1]
        minchrom=np.min(self.rdata,axis=1)/self.rmp
        i=-1
        for idx in idxs:
            i+=1
            if idx[-1] is not None:
                c = [self.rt[idx[1]+self.stidx[i]],idx[-1]]
                x,y,r,xa,ya = figparams.set_textcoords(self.rt,maxchrom,minchrom,axislim,xys,c)
                if xa is not None:
                    arrowprops={'arrowstyle': "simple, tail_width=.3",
                                'color':      u'#A9A9A9'}
                    xy        =(xa,ya)
                else:
                    arrowprops['connectionstyle']="arc3,rad=%3.1f" % r
                    xy        =(self.rt[idx[1]+self.stidx[i]],idx[-1])
                
                self.rawdax.annotate('Marker %d' % idx[0],xy        =xy,
                                                          xycoords  ='data',
                                                          xytext    =(x,y),
                                                          textcoords='data',
                                                          size      =12,
                                                          name      ='Times New Roman',
                                                          va        ="center",
                                                          ha        ="center",
                                                          color     ='red',
                                                          arrowprops=arrowprops)
                xys.append([x,y])
            
        self.figure.canvas.draw()
        
        # if the raw data has been loaded, and the number of methods is larger than 1
        # selection of reference methods for showing is set to be available
        if len(self.methods) > 1:
            self.menutool.entryconfig(0, state='normal')
        # set the menu "Generate report" available
        self.menutool.entryconfig(1, state='normal')
        # reserving the method which is used for MSCC analysis, thus will not be changed if
        # other method is selected for viewing whereas not used for MSCC analysis in result
        # report.
        self.initialmethod = self.method
        gc.collect()

    def drawSingleWVCurve(self,selectwv):
        """ Raise new window for displaying the single wavelength chromatogram.
            To deal with multiple windows intelligently, all currently toplevel windows are stored
            in a list. If a window is closed, the corresponding toplevel instance is set to None. If
            new wavelength is selected for showing, the None in the window list is replaced by
            the new toplevel instance which shows the chromatogram of the wavelength, whereas
            if no None value occurs in the list, i.e. all windows are still opened, the list is
            appended to include newly opened toplevel instance.
        """
        if 'rwvdrawlist' not in self.__dict__.keys():
            self.rwvdrawlist=[]
            self.rwcwins    =[]
        if selectwv in self.rwvdrawlist:
            idx = self.rwvdrawlist.index(selectwv)
            self.rwcwins[idx].attributes('-topmost',True)
            self.rwcwins[idx].attributes('-topmost',False)
            return

        # draw the single wavelength chromatogram in raised window
        win = tk.Toplevel()
        win.wm_title("Single Wavelength Chromatogram")
        
        figure=Figure(figsize=(6,3), facecolor='white', edgecolor='white')
        ax 	  =figure.add_subplot(111)
        curve =self.rdata[:,self.wv==selectwv]
        # get parameters for tick setting
        texts  =['Current wavelength: %d nm' % selectwv,'','rswv']
        mp, yuplim, text = figparams.set_figureparams(curve,self.rt,ax,texts)

        # plot
        ax.plot(self.rt,curve/mp)
        ax.set_xlabel('Retention Time/min', fontdict={'size':12,'fontname':'Times New Roman'})
        
        canvas = FigureCanvas(figure, master=win)
        canvas.get_tk_widget().pack(side='top', fill='both', expand=1)
        canvas.show()
        
        toolbar = NavigationToolbar2TkAgg(canvas, win)
        toolbar.update()
        canvas._tkcanvas.pack(side='top', fill='both', expand=1)

        # get the index for the newly opened window
        if None in self.rwvdrawlist:
            idx = self.rwvdrawlist.index(None)
            self.rwvdrawlist[idx]=selectwv
            self.rwcwins[idx] 	 =win
        else:
            idx = len(self.rwvdrawlist)
            self.rwvdrawlist.append(selectwv)
            self.rwcwins.append(win)
        win.protocol("WM_DELETE_WINDOW", lambda: self.singleWVWinQuit(idx))

    def singleWVWinQuit(self,index):
        """ Close the single wavelength chromatogram window corresponding to index """
        self.rwcwins[index].destroy()
        self.rwcwins[index]    =None
        self.rwvdrawlist[index]=None


# ----------------------------------------------------------------------------------------------
## Load and draw the reference curve
class DrawRefCurve(object):
    """ Load and draw reference curve """
    def __init__(self, parent):
        if 'refax' in parent.__dict__.keys():
            self = parent.refax
        
        self.figure=parent.figure
        self.method=parent.method
        self.wvtxt =parent.wvtxt
        
        self.refDataLoad()
        self.drawRefCurve()
    
    def refDataLoad(self):
        """ Load reference data and corresponding information wavelength, retention
            time, marker retention time. """
        refdfile =os.path.join(CURRENTLIBPATH,self.method+'.txt')
        refinfo  =os.path.join(CURRENTLIBPATH,self.method+'.info')
        self.refdata =np.loadtxt(refdfile)
        with open(refinfo,'r') as f:
            for line in f:
                eqstr=line.find('=')
                if eqstr is not -1:
                    line=line.strip()
                    if line.startswith('MARKERRT'):
                        t  = line[eqstr+1:].split(';')
                        rts= []
                        for s in t:
                            rts.append([float(v) for v in s.split(' ')])
                        self.markerrt=rts
                    elif line.startswith('WVMAIN'):
                        self.currwv=int(line[eqstr+1:])
                    elif line.startswith('REFMRT'):
                        string=line[eqstr+1:]
                        self.refmrt=0. if string == 'none' else float(string)
                    elif line.startswith('TIME'):
                        self.rt    =np.array([float(t) for t in line[eqstr+1:].split(' ')])
                    elif line.startswith('WAVELENGTH'):
                        self.wv    =np.array([int(t) for t in line[eqstr+1:].split(' ')])

    def drawRefCurve(self):
        """ Draw reference and customize the annotation which can be edited by user. """
        try:
            self.refdax.clear()
        except AttributeError:
            self.refdax = self.figure.add_subplot(2,1,2)
        
        # set up curves
        curve  =self.refdata[:,self.wv==self.currwv]
        texts  =[u'Wavelength: %d nm' % self.currwv,u'Method: %s' % self.method,'ref']
        mp, yuplim, text = figparams.set_figureparams(curve,self.rt,self.refdax,texts)
        curve /=mp
        yuplim/=mp
        self.refdax.plot(self.rt,curve)
        self.refdax.set_xlabel('Retention Time/min', fontdict={'size':12, 'fontname':'Times New Roman'})
        self.refxylims=[self.refdax.get_xlim(),self.refdax.get_ylim()]
        self.wvtxt[1] =text

        # find centre of marker peak for annotation
        cnter = []
        for mrt in self.markerrt:
            lidx=np.where(self.rt<=mrt[0])[0][-1]
            idx =np.argmax(curve[(self.rt>=mrt[0])&(self.rt<=mrt[1])])
            cnter.append(lidx+idx)
        # annotate marker text to the curve
        arrowprops={'arrowstyle': "simple,tail_width=0.3", 'color': u'#A9A9A9'}
        yhei=yuplim*0.1
        n   =0
        for site in cnter:
            n += 1
            textxy = (self.rt[site],curve[site]+yhei)
            if textxy[1]>yuplim*0.9: textxy = (self.rt[site]*1.05,yuplim*0.9)
            self.refdax.annotate('Marker %d' % n,xy       =(self.rt[site],curve[site]),
                                                xycoords  ='data',
                                                xytext    =textxy,
                                                textcoords='data',
                                                size      =12,
                                                name      ='Times New Roman',
                                                va        ="center",
                                                ha        ="center",
                                                color     ='red',
                                                arrowprops=arrowprops)
        if 'refdax' in self.__dict__.keys(): self.figure.canvas.draw()


# ----------------------------------------------------------------------------------------------
## Library constructor
class LibConstructor(object):
    """ Construct library of reference data. The library is a folder located in
        same path of componentMatcher. """
    def __init__(self, parent):
        try:
            self.methods=parent.methods
        except AttributeError:
            self.methods=get_methodlist()
        self.toolmenu=parent.menutools
        self.root    =parent.root
        self.setmenu =True if 'rawax' in parent.__dict__.keys() else False
        
        f = self.loadMethodData()
        if f is None: return
        self.paramInputDlg()
        self.drawRefCurves()
        
    def loadMethodData(self):
        """ Load method data for library construction. """
        dfname = tkd.askopenfilename(defaultextension='.txt',
                                     filetypes       =[('all files','.*'), ('text files','.txt')],
                                     title           ='Select Reference DATA',
                                     initialfile     =r'F:\data\LC\ITF\XYS-CBZ\cbzrh_converted')
        if len(dfname)==0: return
        
        tidx  =dfname.rfind('/d')
        rtfile=dfname[:tidx]+'/t'+dfname[tidx+2:]
        wvfile=dfname[:tidx]+'/w'+dfname[tidx+2:]
        if not os.path.isfile(wvfile) or not os.path.isfile(rtfile):
            tkm.showerror('File Not Exist',
                          'No such wavelength file existed, please check it.'+\
                          '\nThis is probably caused by selecting incorrect raw data'+\
                          'file, or the absence of such file after data conversion.')
            return
        self.refdata, self.refrt, self.refwaves=CMio.loadtxt(dfname, rtfile, wvfile)
        self.currminwv=np.min(self.refwaves)
        self.dfname   =dfname
        return ''

    def paramInputDlg(self):
        """ Input dialogue for inputting method parameters to construct method library. """
        # format parameter for input name
        argsm ={'font': ('Times',12,'bold'), 'anchor': 'w'}
        # format parameter for annotation of input name
        argsa ={'font': ('Times',10), 'anchor': 'nw', 'fg': u'#2E8B57', 'justify': 'left'}
        # texts
        texts =[['Method Name:','nameanno'],
                ['Marker RT:','markerrtanno'],
                ['Reference MRT:','refmrtanno'],
                ['Wavelength:','waveanno']]
        labelpackparam1 = [{'row':0, 'columnspan':2, 'sticky':'w'},
                           {'row':3, 'columnspan':2, 'sticky':'w'},
                           {'row':6, 'column':0, 'sticky':'w'},
                           {'row':6, 'column':1, 'sticky':'w', 'padx':5}]
        labelpackparam2 = [{'row':1, 'columnspan':2, 'sticky':'w'},
                           {'row':4, 'columnspan':2, 'sticky':'w'},
                           {'row':7, 'column':0, 'sticky':'w', 'pady':0},
                           {'row':7, 'column':1, 'sticky':'w', 'padx':5}]
        entpackparam = [{'row':2, 'columnspan':2, 'sticky':'we'},
                        {'row':5, 'columnspan':2, 'sticky':'we'},
                           {'row':8, 'column':0, 'sticky':'wens', 'pady':5},
                           {'row':8, 'column':1, 'sticky':'wens', 'padx':5, 'pady':5}]
        
        # set up window and parameters of window
        win = tk.Toplevel()
        win.config(borderwidth=0)
        win.bind('<Return>',(lambda event: self.fetchEntry))
        win.title('Input Method Data Paramters...')
        win.resizable(width=False, height=False)
        win.transient(self.root) # Make Toplevel a subwindow on the root window
        
        # add figure window in the parameter input dialog
        figure =Figure(figsize=(8,3), facecolor='white', edgecolor='white')
        
        canvas =FigureCanvas(figure, master=win)
        canvas.get_tk_widget().pack(side='top', fill='both', expand=1)
        canvas.show()
        toolbar=NavigationToolbarInLibFig(canvas, win)
        toolbar.update()
        canvas._tkcanvas.pack(side='top', fill='both', expand=1)

        # add the entry widgets for parameter inputs
        paramwin = tk.Frame(win,padx=5)
        paramwin.pack(side='top',fill='both',expand=1)
        inputs=[]
        for i in xrange(4):
            tk.Label(paramwin, text=texts[i][0], **argsm).grid(**labelpackparam1[i])
            tk.Label(paramwin, text=DIAGTEXT[texts[i][1]], **argsa).grid(**labelpackparam2[i])
            ent = tk.Entry(paramwin)
            ent.grid(**entpackparam[i])
            inputs.append(ent)
        
        tk.Button(paramwin,text='OK',command=self.fetchEntry,cursor='hand2').\
                           grid(row=9,column=1,sticky=tk.E)
        self.paramwin=win
        self.figure  =figure
        self.entries =inputs

    def drawRefCurves(self):
        """ Display the selected reference method data for facilitating specification of parameters
            such as retention times of markers and threshold of wavelength. The wavelength threshold
            is used to eliminate the influence of chromatographic conditions which always produce
            serious baseline distortion. """
        ax=self.figure.add_subplot(111)
        # plot
        ax.plot(self.refrt,self.refdata[:,self.refwaves>=self.currminwv])
        ax.set_position([0.078,0.15,0.9,0.76])
        ax.set_xlabel('Retention Time/min', fontdict={'size':12,'fontname':'Times New Roman'})
        ax.tick_params(labelsize=10)
        activetxt =ax.text(0.66, 0.92, 'Click to SET wavelength threshold',
                                fontname ='Times New Roman',
                                color    ='r',
                                size     =12,
                                transform=ax.transAxes,
                                bbox     ={'ec':'k', 'fc':'none', 'boxstyle':'round,pad=.2'},
                                picker   =True)
        ax.text(-0.002,1.012,'Ref file name: %s' % self.dfname,fontname='Times New Roman',
                             color    ='r',
                             size     =10,
                             transform=ax.transAxes)
        self.wvtinfo=ax.text(0.64,1.02,'Current wavelength threshold: %d nm' % self.currminwv,
                                       fontname ='Times New Roman',
                                       transform=ax.transAxes,
                                       size     =12,
                                       color    ='g')
        
        self.figure.canvas.mpl_connect('pick_event', lambda event: self.wvSelecter())
        self.axes=ax

    def wvSelecter(self):
        """ Select wavelength threshold of current reference method data """
        waves =self.refwaves[self.refwaves<=280]
        params=PARAMS['wvsel']
        params['lists']=waves
        sl   =Selector(self.root, params)
        value=sl.value()
        if value is None: return

        self.paramwin.attributes('-topmost',True)
        self.paramwin.attributes('-topmost',False)
        
        self.selectwv=int(value)
        if self.selectwv==self.currminwv: return
        self.updateRefPlot()

    def updateRefPlot(self):
        """ Update the reference method figure after specifying the wavelength threshold. """        
        if self.selectwv < self.currminwv:
            # add new chromatograms with wavelength less than currently specified wavelength
            # threshold
            curves = self.refdata[:,(self.refwaves>=self.selectwv)&(self.refwaves<self.currminwv)]
            lines = self.axes.plot(self.refrt,curves)
            self.axes.lines[:] = self.axes.lines[-len(lines):]+self.axes.lines[:-len(lines)]
        else:
            nlines = ((self.refwaves<self.selectwv) & (self.refwaves>=self.currminwv)).sum()
            del self.axes.lines[:nlines+1]

        # reset y limits
        self.axes.relim()
        self.axes.autoscale_view()
        # reset text
        self.wvtinfo.set_text('Current wavelength threshold: %d nm' % self.selectwv)
        # update figure
        self.figure.canvas.draw()
        # update current wavelength threshold
        self.currminwv = self.selectwv
    
    def fetchEntry(self):
        """ Fetch the entries and write to 'info' file """
        F=np.ones(len(self.entries),dtype=bool)
        n=0
        for ent in self.entries:
            if len(ent.get().strip())==0:
                F[n]=False
            n += 1
        if not any(F): return
        
        if self.isValidEntry():
            name=self.entries[0].get()
            if name in self.methods:
                c = tkm.askyesno('Warning',DIAGTEXT['namewarnmsg'],icon='warning')
                # Set the parameter window the topmost for re-input.
                self.paramwin.attributes('-topmost',True)
                self.paramwin.attributes('-topmost',False)
                if c: self.writeInfo(name,False)
            else:
                self.writeInfo(name,True)
    
    def writeInfo(self, filename, addtag):
        """ Write method parameters into info file. """
        # create the lib folder if not exist.
        try:
            os.makedirs(CURRENTLIBPATH)
        except OSError:
            if not os.path.isdir(CURRENTLIBPATH):
                raise
        
        refdata      =self.refdata[:,self.refwaves>=self.currminwv]
        self.refwaves=self.refwaves[self.refwaves>=self.currminwv]
        fullinfoname =os.path.join(CURRENTLIBPATH,filename+'.info')
        libinfo      =DIAGTEXT['libinfo']

        # write to .info file
        with open(fullinfoname,'w') as f:
            for i in xrange(len(self.entries)):
                string = self.entries[i].get()
                string = string.strip()
                if string.endswith(';'): string = string[:-1]
                if len(string) is 0: string = 'none'
                f.write(libinfo[i]+string+'\n')
                
            f.write(libinfo[i+1]+'%d\n' % self.currminwv)
            
            f.write(libinfo[i+2])
            for value in self.refrt: f.write('%f ' % value)
            
            f.write('\n'+libinfo[i+3])
            for value in self.refwaves: f.write('%d ' % value)
        self.paramwin.destroy()
        
        # save data to the lib file
        fulldataname = os.path.join(CURRENTLIBPATH,filename+'.txt')
        np.savetxt(fulldataname,refdata,fmt='%f')

        if addtag:
            self.methods.append(filename)
        if len(self.methods)>1 and self.setmenu:
            self.toolmenu.entryconfig(0, state='normal')
    
    def isValidEntry(self):
        """ Check whether the input parameters for specefying library data are valid """
        c = True
        rtstring = self.entries[1].get()
        if not self.validNameCheck(self.entries[0].get()):
            tkm.showerror('Invalid Name','Method name must not be empty and be all valid '+\
                                         'characters for defining a file name.')
            c = False
        elif not self.markerRTCheck(rtstring):
            tkm.showerror('Invalid Input','Invalid inputs for specifying marker retention '+\
                                          'time, please check it!\nTips: This is probably '+\
                                          'caused by incorrect format or time range specified '+\
                                          'for a marker.')
            c = False
        elif not self.refMRTCheck(rtstring,self.entries[2].get()):
            tkm.showerror('Invalid Input','Invalid inputs for specifying reference marker '+\
                                          'retention time, please check it!\nTips: Retention '+\
                                          'time must be valid number between the time range '+\
                                          'of any marker.')
            c = False
        elif not self.selectiveWVCheck(self.entries[3].get()):
            tkm.showerror('Invalid Input','The wavelength selected for fingerprint showing must '+\
                                          'be in experimental wavelength list')
            c = False
        elif not self.markerRTWarning(rtstring):
            c = False
            
        # Set the parameter window the topmost for re-input.
        self.paramwin.attributes('-topmost',True)
        self.paramwin.attributes('-topmost',False)
        return c
            
    def validNameCheck(self,string):
        """ Check whether the input method name is valid as this is also used as its lib file name. """
        if len(string.strip()) == 0:
            return False

        try:
            open(string,'w').close()
            os.remove(string)
            return True
        except IOError:
            return False
    
    def markerRTCheck(self,string):
        """ Check the format of input retention times of markers """
        string = string.strip()
        if string.endswith(';'): string=string[:-1]
        if not string: return False
            
        times=[s for s in string.split(';')]
        n=0
        for time in times:
            t =[s for s in time.split(' ') if s and not s.isspace()]
            for j in t:
                try:
                    float(j)
                    n += 1
                except ValueError:
                    return False
            if n != 2:
                return False
            if float(time.split(' ')[1]) <= float(time.split(' ')[0]):
                return False
            n=0
            
        return True

    def refMRTCheck(self,rtstring,string):
        """ Check whether the retention time of reference marker is valid. The time must
            be a valid number between the range of any marker input previously. But if
            there is no reference marker, this can be left empty. """
        string  =string.strip()
        if len(string) == 0:
            return True
        # if the last one is not a number, remove it and recheck the input to identify
        # whether it is a number. If not, return False
        try:
            float(string[-1])
        except ValueError:
            string=string[:-1]

        try:
            rrt =float(string)
        except ValueError:
            return False
        
        rtstring=rtstring.strip()
        if rtstring.endswith(';'): rtstring=rtstring[:-1]
        
        times=[s for s in rtstring.split(';')]
        c    =False
        for time in times:
            t=[float(s) for s in time.split(' ') if s and not s.isspace()]
            if t[0]<=rrt<=t[1]:
                c=True
                break
        return c
    
    def selectiveWVCheck(self,string):
        """ Check the input selective wavelength for fingerprint """
        if not string.strip(): return False
        try:
            wv = int(string)
        except ValueError:
            return False
        
        if not (self.refwaves==wv).any():
            return False
        return True

    def markerRTWarning(self,string):
        """ Check the retention time specified for markers. If any of the time input less then
            5 min, a warning will be raised for checking. """
        string = string.strip()
        if string.endswith(';'): string=string[:-1]
        if not string: return False
        
        times=[s for s in string.split(';')]
        t 	 =[]
        for time in times:
            t.append([float(s) for s in time.split(' ') if s and not s.isspace()])
        t.sort()
        if t[0][0] <= 5:
            a = tkm.askyesno('Time Warning','Retention times specified for markers are less'+\
                                            ' then 5 min!\nAre you sure?',
                                            icon='warning')
            if not a:
                return False
        
        return True
    

# ----------------------------------------------------------------------------------------------
## Generate report
class ReportGenerator(object):
    """ Display and save results. In addition, a hyperlink is set in openning window, thus
        a popup figure will be generated to compare the spectrum of corresponding marker and
        matched marker in formula data. If any marker specified is not matched in formula
        data according to currently set score threshold, the spectrum where lowest score
        locates is used for comparison.
           Input:
               parent: Parent object contains formula and reference 2D data, marker information
                       in the two data. """
    attrs = ['wv','root','rmkrt','mkrt','nmk', 'rnmk','ms','rms','refmkidx','amt']
    def __init__(self, parent):
        self.method=parent.initialmethod
        idx        =parent.rfname.rfind('/d')
        self.rfile =parent.rfname[idx+2:]
        self.minfo =parent.targetidx
        for attr in self.attrs: setattr(self, attr, parent.__dict__[attr])
        
        self.makeShowWin()
        self.showText()

    def makeShowWin(self):
        """ Construct main window for showing results """
        win     =tk.Toplevel()
        win.transient(self.root) # Make Toplevel a subwindow on the root window
        framewin=tk.Frame(win)
        framewin.pack(side='top',fill='both',expand=1)
        sbar    =tk.Scrollbar(framewin)
        sbar.pack(side='right', fill='y')
        txtwin  =tk.Text(framewin, relief='sunken')
        sbar.config(command=txtwin.yview)
        
        txtwin.config(yscrollcommand=sbar.set)
        txtwin.config(width=75, height=25)
        txtwin.pack(side='left', expand=1, fill='both')
        
        tk.Button(win,text='Save',command=self.saveToFile,cursor ='hand2').pack(side='top')

        self.txtwin= txtwin

    def showText(self):
        """ Display results """
        self.txtwin.insert('1.0','Method Name: '+self.method+'\n')
        self.txtwin.insert('2.0','Raw File:'+' '*11+self.rfile+'\n')
        self.txtwin.insert('3.0','Statistics:'+' '*10+str(self.rnmk)+' of total '+\
                                 str(self.nmk)+' markers are found\n')
        self.txtwin.insert('4.0','\nDETAIL INFORMATION:\n')
        self.txtwin.insert('6.0','Marker ID\t\tMatched\t\tRaw RT/min'+\
                                 '\t\tRef RT/min\t\tView\n')
        n = 6
        for i in xrange(self.nmk):
            n+=1
            line=str(n)
            txt ='%d\t\tN\t\t-\t\t%.3f\t\tspectrum\n' % (i+1,self.mkrt[i])
            if self.minfo[i][-1] is not None:
                txt=txt.replace('N','Y')
                txt=txt.replace('-','%.3f' % self.rmkrt[i])
            if self.amt[i]: txt=txt[0]+'*'+txt[1:] # this is ambiguous
            self.txtwin.insert(line+'.0', txt)
            
            if self.minfo[i][1] is not None:
                # specify tag and bind to function for showing spectrum
                eidx=self.txtwin.index(line+'.0 lineend')       # index of line end
                c   =int(eidx[eidx.find('.')+1:])               # convert to integer
                sidx=line+'.'+str(c-len('spectrum'))            # start index of tag
                # set tag
                tagname ='spec_%d' % i
                self.txtwin.tag_add(tagname, sidx, line+'.end')
                self.txtwin.tag_bind(tagname,'<Button-1>', self.showSpec)
                self.txtwin.tag_bind(tagname,'<Enter>',self._enter)
                self.txtwin.tag_bind(tagname,'<Leave>',self._leave)
                self.txtwin.tag_config(tagname, underline=1, foreground='red')

            # if reference marker exist, highlight it
            if i==self.refmkidx:
                eidx=line+'.'+str(c-len('spectrum')-2)
                self.txtwin.tag_add('refmarker', line+'.0',eidx)
                self.txtwin.tag_config('refmarker', font=('Times',10,'bold'), foreground='red')

        # add the notes
        self.txtwin.insert(str(n+1)+'.0', '\n')
        self.txtwin.insert(str(n+2)+'.0', 'NOTE:\n')
        self.txtwin.insert(str(n+3)+'.0',
                           '1. The line highlighted in bold and red is the reference marker.\n')
        if self.amt.count(True)>0:
            self.txtwin.insert(str(n+4)+'.0',
                               "2. Lines marked by '*' are considered to be ambiguous. "+\
                               "This is probably because\n    these markers are assigned"+\
                               " to same peak in formula data.\n")
        
        self.txtwin.config(state='disabled', font=('Times',10))

    def showSpec(self,event):
        """ Popup figure to show spectra of reference method and formula data for
        comparison """
        name, =self.txtwin.tag_names(tk.CURRENT)
        idx   =int(name[name.find('_')+1:])
        labels=['method spectrum','formula spectrum']

        win = tk.Toplevel()
        win.wm_title("Spectra")
        figure=Figure(figsize=(6,3), facecolor='white', edgecolor='white')
        ax 	  =figure.add_subplot(111)

        # plot
        ms    =self.ms[idx]/np.max(abs(self.ms[idx]))
        rms   =self.rms[idx]/np.max(abs(self.rms[idx]))
        # to avoid negative plotting
        if np.max(ms) < .2: ms += 1.
        if np.max(rms) < .2: rms += 1.
        lines =ax.plot(self.wv,ms,self.wv,rms,'r--')
        for i in xrange(len(lines)): lines[i].set_label(labels[i])
        lg    =ax.legend(fontsize=10,borderpad=0.)
        lg.draw_frame(False)
        ax.set_xlabel('Wavelength/nm', fontdict={'size':12,'fontname':'Times New Roman'})
        ax.set_position([.08,.15,.88,.8])
        ax.tick_params(labelsize=10)
        
        canvas = FigureCanvas(figure, master=win)
        canvas.get_tk_widget().pack(side='top', fill='both', expand=1)
        canvas.show()
        
        toolbar = NavigationToolbarInLibFig(canvas, win)
        toolbar.update()
        canvas._tkcanvas.pack(side='top', fill='both', expand=1)
                
    def saveToFile(self):
        """ Save the results to file """
        file = tkd.asksaveasfile(mode='w', defaultextension=".txt",
                                           filetypes=[('all files', '.*'), ('text files', '.txt')],
                                           title='Save results')
        if file is None: return
        file.write('Method Name: '+self.method+'\n')
        file.write('Raw File: '+self.rfile+'\n')
        file.write('Statistics: %d of total %d markers are found\n' % (self.rnmk,self.nmk))
        file.write('\nDETAIL:\n')
        file.write('Marker ID\t\tMatched\t\tRaw RT/min\t\tRef RT/min\n')
        for i in xrange(self.nmk):
            if self.minfo[i][-1] is not None:
                file.write(str(i+1)+'\t'*4+'Y'+'\t'*4+str(self.rmkrt[i])+\
                           '\t'*4+str(self.mkrt[i])+'\n')
            else:
                file.write(str(i+1)+'\t'*4+'N'+'\t'*4+'-'+'\t'*4+str(self.mkrt[i])+'\n')
        file.close()

    def _enter(self,event):
        """ set cursor when mouse moves on the highlighted tag """
        self.txtwin.config(cursor="hand2")

    def _leave(self,event):
        """ set cursor when mouse leaves the highlighted tag """
        self.txtwin.config(cursor="")


def main():
    root = tk.Tk()
    root.title("componentMatcher")
    MainGUI(root)
    root.mainloop()
    
if __name__ == '__main__':
    main()
